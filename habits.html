<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Habit Tracker ‚Äî Supabase</title>

    <!-- PWA and iOS specific meta tags -->
    <link rel="manifest" href="manifest-habit.json">
    <meta name="theme-color" content="#111827">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Habit Tracker">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/ef4444/ffffff?text=H">

    <!-- iOS Splash Screens -->
   <link rel="apple-touch-icon" href="/icons/apple-touch-icon-180.png">
   <link rel="apple-touch-startup-image" href="/icons/splash-750x1334.png"
  media="(device-width: 375px) and (device-height: 667px)
  and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .date-scroller::-webkit-scrollbar { display: none; }
        .date-scroller { -ms-overflow-style: none; scrollbar-width: none; }
        .view { transition: all 0.3s ease-in-out; }
        .toast-notification, .modal-container { transition: opacity 0.3s ease-in-out; }
        .view.hidden { display: none; }
        .day-btn.active, .time-range-btn.active { background-color: #EF4444; color: #FFFFFF; font-weight: 600; }
        .theme-btn.active { background-color: white; color: #111827; }
        .dark .theme-btn.active { background-color: #4B5563; color: white; }
        .achievement-unlocked { box-shadow: 0 0 15px rgba(250,204,21,0.6); animation: glow 1.5s infinite alternate; }
        @keyframes glow { from { box-shadow: 0 0 5px rgba(250,204,21,0.4);} to { box-shadow: 0 0 20px rgba(250,204,21,0.8);} }
        .habit-swipe-container, .hidden-habit-swipe-container { position: relative; overflow: hidden; border-radius: 0.75rem; user-select: none; }
        .habit-content, .hidden-habit-tile { transition: transform 0.3s ease-out, background 0.5s ease-out, opacity 0.5s ease-out; position: relative; z-index: 10; cursor: grab; }
        .habit-actions { position: absolute; top: 0; right: 0; height: 100%; display:flex; align-items:center; z-index:1; }
        .habit-action-btn { width:70px; height: 100%; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-size:0.75rem; font-weight:600; cursor:pointer; }
    </style>
</head>
<body class="antialiased bg-gray-100 dark:bg-black text-gray-900 dark:text-gray-200">

<div id="app-container">
    <div id="main-view" class="view p-5 pb-24 min-h-screen">
        <header class="flex justify-between items-center mb-6">
            <button class="flex items-center gap-1.5 bg-white dark:bg-[#1E1E1E] px-3 py-1.5 rounded-full text-sm font-semibold">
                <span>All</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
            </button>
            <h1 id="header-title" class="text-xl font-bold">Today</h1>
            <button class="w-8 h-8 rounded-full bg-yellow-400 text-black flex items-center justify-center text-lg"><span>üòä</span></button>
        </header>

        <div id="date-scroller-container" class="date-scroller flex space-x-3 overflow-x-auto pb-4 mb-6"></div>
        <div id="habits-container" class="space-y-3"></div>

        <div id="hidden-habits-section" class="fixed bottom-20 left-0 right-0 z-20 px-5 hidden">
            <div id="hidden-habits-header" class="bg-gray-300 dark:bg-gray-800 text-gray-800 dark:text-white font-semibold py-2 px-4 rounded-t-lg cursor-pointer flex justify-between items-center">
                <span>Hidden Habits</span>
                <svg id="hidden-habits-arrow" class="w-5 h-5 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg>
            </div>
            <div id="hidden-habits-list" class="bg-gray-200 dark:bg-gray-900/80 backdrop-blur-sm max-h-0 overflow-y-auto transition-all duration-300 ease-in-out p-0 space-y-2"></div>
        </div>
    </div>

    <div id="stats-view" class="view hidden p-5 pb-24 min-h-screen">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-xl font-bold">Statistics</h1>
        </header>
        <div id="stats-container" class="space-y-6"></div>
    </div>

    <div id="achievements-view" class="view hidden p-5 pb-24 min-h-screen">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <span class="text-2xl">üèÜ</span>
                Achievements
            </h1>
        </header>
        <div id="achievements-container" class="space-y-6"></div>
        <p class="text-center text-gray-500 dark:text-gray-400 mt-8 font-semibold">Keep going to unlock more rewards!</p>
    </div>

    <div id="settings-view" class="view hidden p-5 pb-24 min-h-screen">
        <header class="flex justify-between items-center mb-6">
            <h1 class="text-xl font-bold">Settings</h1>
        </header>
        <div class="space-y-4">
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h2 class="font-bold text-lg mb-3">Appearance</h2>
                <div id="theme-selector" class="flex rounded-lg bg-gray-200 dark:bg-black p-1">
                     <button data-theme="light" class="theme-btn flex-1 py-2 text-sm font-semibold rounded-md transition-colors text-gray-600 dark:text-gray-400">Light</button>
                     <button data-theme="dark" class="theme-btn flex-1 py-2 text-sm font-semibold rounded-md transition-colors text-gray-600 dark:text-gray-400">Dark</button>
                </div>
            </div>
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h2 class="font-bold text-lg mb-2">Data Management</h2>
                <button id="reset-data-btn" class="w-full text-left p-3 bg-red-100 dark:bg-red-900/50 hover:bg-red-200 dark:hover:bg-red-900/80 rounded-lg text-red-700 dark:text-red-300 font-semibold">Reset All Data</button>
                <p class="text-xs text-gray-500 mt-2">This will permanently delete all your habits and progress from Supabase and local cache.</p>
            </div>
        </div>
    </div>
</div>

<div id="add-habit-view" class="fixed inset-0 bg-gray-100 dark:bg-black transform translate-x-full z-50 p-5 overflow-y-auto">
    <header class="flex items-center mb-8">
        <button id="back-btn" class="p-1"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" /></svg></button>
        <h2 id="form-title" class="text-xl font-bold mx-auto">Custom Habit</h2>
        <div class="w-6"></div>
    </header>
    <div class="space-y-4 pb-5">
        <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
            <div class="flex items-center gap-4">
                <button id="icon-preview-btn" class="w-14 h-14 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center justify-center text-3xl flex-shrink-0">‚ûï</button>
                <div class="flex-grow space-y-2">
                    <input id="habit-name-input" type="text" placeholder="Habit name" class="w-full bg-transparent text-lg font-semibold placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none">
                    <input id="habit-category-input" type="text" placeholder="Category (e.g., Health)" class="w-full bg-transparent text-sm text-gray-500 dark:placeholder-gray-400 focus:outline-none">
                </div>
            </div>
        </div>
        <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl flex justify-between items-center">
             <label class="font-semibold">Times Per Day</label>
             <input id="habit-times-per-day-input" type="number" value="1" min="1" class="w-20 bg-gray-200 dark:bg-gray-700 text-center font-semibold rounded-lg py-1 focus:outline-none focus:ring-2 focus:ring-red-500">
        </div>
         <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
            <label class="font-semibold">Target Days</label>
            <div id="form-target-days" class="flex justify-between items-center mt-3"></div>
        </div>
        <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
            <label class="font-semibold">Time Range</label>
            <div id="form-time-range" class="grid grid-cols-2 md:grid-cols-4 gap-2 mt-3"></div>
        </div>
        <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
            <label class="font-semibold">Color</label>
            <div id="form-color-grid" class="grid grid-cols-8 gap-3 py-4 place-items-center"></div>
        </div>
         <button id="save-habit-btn" class="w-full bg-red-500 text-white font-bold py-4 rounded-xl mt-6">Create Habit</button>
    </div>
</div>

<div id="icon-picker-modal" class="modal-container fixed inset-0 bg-black/70 z-[60] hidden items-center justify-center p-5">
    <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl w-full max-w-sm">
        <h3 class="text-lg font-bold text-center mb-4">Choose an Icon</h3>
        <div id="icon-grid" class="grid grid-cols-6 gap-2 max-h-60 overflow-y-auto"></div>
        <button id="close-icon-modal" class="mt-4 w-full py-2 bg-gray-200 dark:bg-gray-700 rounded-lg">Close</button>
    </div>
</div>

<div id="context-menu-modal" class="modal-container fixed inset-0 bg-black/70 z-[60] hidden items-end justify-center p-5">
    <div class="bg-white dark:bg-[#1E1E1E] p-2 rounded-xl w-full max-w-sm space-y-2">
        <button id="edit-habit-btn" class="w-full text-center p-3 font-semibold bg-gray-200/50 dark:bg-gray-700/50 hover:bg-gray-200 dark:hover:bg-gray-700 rounded-lg">Edit Habit</button>
        <button id="delete-habit-btn" class="w-full text-center p-3 font-semibold text-red-600 dark:text-red-400 bg-red-100 dark:bg-red-900/50 hover:bg-red-200 dark:hover:bg-red-900/80 rounded-lg">Delete Habit</button>
        <button id="close-context-menu" class="w-full text-center p-3 font-bold mt-2 bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 rounded-lg">Cancel</button>
    </div>
</div>

<div id="confirm-modal" class="modal-container fixed inset-0 bg-black/70 z-[70] hidden items-center justify-center p-5">
    <div class="bg-white dark:bg-[#1E1E1E] p-5 rounded-xl w-full max-w-sm text-center">
        <h3 id="confirm-title" class="text-lg font-bold mb-2">Are you sure?</h3>
        <p id="confirm-message" class="text-sm text-gray-500 dark:text-gray-400 mb-6">This action cannot be undone.</p>
        <div class="flex gap-4">
            <button id="confirm-cancel-btn" class="w-full py-2 bg-gray-200 dark:bg-gray-700 rounded-lg font-semibold">Cancel</button>
            <button id="confirm-action-btn" class="w-full py-2 bg-red-600 text-white rounded-lg font-semibold">Confirm</button>
        </div>
    </div>
</div>

<footer class="fixed bottom-0 left-0 right-0 bg-white dark:bg-black border-t border-gray-200 dark:border-gray-800 p-2 flex justify-around items-center z-50">
    <button data-view="main-view" class="nav-btn p-2 text-red-500"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" /></svg></button>
    <button data-view="stats-view" class="nav-btn p-2 text-gray-500 dark:text-gray-400"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg></button>
    <button id="add-habit-btn" class="w-16 h-16 bg-red-500 rounded-full flex items-center justify-center text-white -mt-8 border-4 border-white dark:border-black"><svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
    <button data-view="achievements-view" class="nav-btn p-2 text-gray-500 dark:text-gray-400"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z" /></svg></button>
    <button data-view="settings-view" class="nav-btn p-2 text-gray-500 dark:text-gray-400"><svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg></button>
</footer>

<script type="module">
/* ===========================
   Supabase config (from user)
   =========================== */
import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm";

const SUPABASE_URL = 'https://wxcribfgsredterukkzt.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind4Y3JpYmZnc3JlZHRlcnVra3p0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA5MjU0NTUsImV4cCI6MjA3NjUwMTQ1NX0.ZRl5Z6MAGAkwhoRmH60-AXue0AbS9HQ1SHtoHuEkbaM';
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

/* ===========================
   App code (mostly same UI)
   =========================== */
document.addEventListener('DOMContentLoaded', async () => {
    // DOM elements
    const appContainer = document.getElementById('app-container');
    const headerTitle = document.getElementById('header-title');
    const habitsContainer = document.getElementById('habits-container');
    const dateScrollerContainer = document.getElementById('date-scroller-container');
    const hiddenHabitsSection = document.getElementById('hidden-habits-section');
    const hiddenHabitsHeader = document.getElementById('hidden-habits-header');
    const hiddenHabitsList = document.getElementById('hidden-habits-list');
    const hiddenHabitsArrow = document.getElementById('hidden-habits-arrow');
    const addHabitView = document.getElementById('add-habit-view');
    const saveHabitBtn = document.getElementById('save-habit-btn');
    const formTitle = document.getElementById('form-title');
    const habitNameInput = document.getElementById('habit-name-input');
    const habitCategoryInput = document.getElementById('habit-category-input');
    const habitTimesPerDayInput = document.getElementById('habit-times-per-day-input');
    const formTargetDays = document.getElementById('form-target-days');
    const formTimeRange = document.getElementById('form-time-range');
    const iconPreviewButton = document.getElementById('icon-preview-btn');
    const formColorGrid = document.getElementById('form-color-grid');
    const backBtn = document.getElementById('back-btn');
    const iconPickerModal = document.getElementById('icon-picker-modal');
    const iconGrid = document.getElementById('icon-grid');
    const contextMenuModal = document.getElementById('context-menu-modal');
    const confirmModal = document.getElementById('confirm-modal');
    const themeSelector = document.getElementById('theme-selector');

    // State
    let selectedDate = new Date();
    let habits = []; // local cache: array of habit objects from DB
    let history = {}; // { 'YYYY-MM-DD': { habitId: { count, status } } }
    let currentEditingHabitId = null;
    let hiddenHabitsState = {}; // Store hidden habits locally
    let offlineQueue = []; // For PWA offline sync

    // UI constants
    const COLORS = [
        { main: '#3B82F6', dark: '#1E3A8A' }, // blue-500, blue-800
        { main: '#FBBF24', dark: '#B45309' }, // amber-400, amber-700
        { main: '#2DD4BF', dark: '#0F766E' }, // teal-400, teal-700
        { main: '#F87171', dark: '#991B1B' }, // red-400, red-800
        { main: '#4ADE80', dark: '#166534' }, // green-400, green-800
        { main: '#A78BFA', dark: '#5B21B6' }, // violet-400, violet-700
        { main: '#F472B6', dark: '#9D174D' }, // pink-400, pink-800
        { main: '#818CF8', dark: '#3730A3' }  // indigo-400, indigo-800
    ];
    const ICONS = ['üìö','üèÉ','üíª','üßò','üíß','üé®','üéµ','üßπ','üí∞','üí™','üéØ','üó£Ô∏è','‚úèÔ∏è','üå±','üåÖ','üçé','‚úçÔ∏è','üí°'];
    const DAYS_OF_WEEK = ['S','M','T','W','T','F','S'];
    const TIME_RANGES = ['Anytime','Morning','Afternoon','Evening'];

    // Helpers
    const toISODateString = date => new Date(date.getFullYear(), date.getMonth(), date.getDate()).toISOString().split('T')[0];
    const isSameDay = (d1, d2) => d1.getFullYear()===d2.getFullYear() && d1.getMonth()===d2.getMonth() && d1.getDate()===d2.getDate();

    const showToast = (message) => {
        const toast = document.createElement('div');
        toast.className = 'toast-notification fixed bottom-24 left-1/2 -translate-x-1/2 bg-gray-800 text-white px-4 py-2 rounded-full text-sm opacity-0 transform translate-y-2 z-[100]';
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(()=> { toast.classList.remove('opacity-0','translate-y-2'); }, 10);
        setTimeout(()=> {
            toast.classList.add('opacity-0','translate-y-2');
            toast.addEventListener('transitionend', ()=> toast.remove());
        }, 2000);
    };

    const showModal = (modal) => { modal.classList.remove('hidden'); modal.classList.add('flex'); }
    const hideModal = (modal) => modal.classList.add('hidden');

    const showConfirmation = (title, message, onConfirm) => {
        document.getElementById('confirm-title').textContent = title;
        document.getElementById('confirm-message').textContent = message;
        showModal(confirmModal);

        const confirmBtn = document.getElementById('confirm-action-btn');
        const cancelBtn = document.getElementById('confirm-cancel-btn');

        const confirmHandler = () => { onConfirm(); hideModal(confirmModal); cleanup(); };
        const cancelHandler = () => { hideModal(confirmModal); cleanup(); };

        const cleanup = () => {
            confirmBtn.removeEventListener('click', confirmHandler);
            cancelBtn.removeEventListener('click', cancelHandler);
        };

        confirmBtn.addEventListener('click', confirmHandler);
        cancelBtn.addEventListener('click', cancelHandler);
    };

    // -------------------------
    // Offline Sync Logic
    // -------------------------
    const saveOfflineQueue = () => {
        localStorage.setItem('offlineQueue', JSON.stringify(offlineQueue));
    };

    const addToOfflineQueue = (action) => {
        offlineQueue.push(action);
        saveOfflineQueue();
    };

    const syncOfflineActions = async () => {
        if (offlineQueue.length === 0) {
            return;
        }

        showToast('Back online. Syncing your changes...');
        let failedActions = [];

        for (const action of offlineQueue) {
            try {
                switch (action.type) {
                    case 'CREATE_HABIT':
                        await supabase.from('habits').insert([action.payload]).select().single();
                        break;
                    case 'UPDATE_HABIT':
                        await supabase.from('habits').update(action.payload.partial).eq('id', action.payload.id);
                        break;
                    case 'DELETE_HABIT':
                        await supabase.from('history').delete().eq('habit_id', action.payload.id);
                        await supabase.from('habits').delete().eq('id', action.payload.id);
                        break;
                    case 'UPSERT_HISTORY':
                        await upsertHistoryEntryOnSupabase(action.payload.habitId, action.payload.isoDate, action.payload.entry, true);
                        break;
                    case 'REMOVE_HISTORY':
                        await removeHistoryEntryOnSupabase(action.payload.habitId, action.payload.isoDate, true);
                        break;
                }
            } catch (error) {
                console.error('Failed to sync action:', action, error);
                failedActions.push(action);
            }
        }

        offlineQueue = failedActions;
        saveOfflineQueue();

        if (failedActions.length === 0) {
            showToast('All changes synced successfully!');
            await loadDataFromSupabase(); // Reload all data to be sure
            renderHabits();
            renderDateScroller();
        } else {
            showToast('Some changes could not be synced.');
        }
    };


    // -------------------------
    // Supabase interaction
    // -------------------------

    // Load habits and history from Supabase into local caches
    async function loadDataFromSupabase() {
        try {
            // Load habits
            let { data: habitsData, error: habitsError } = await supabase
                .from('habits')
                .select('*')
                .order('id', { ascending: true });

            if (habitsError) throw habitsError;
            habits = (habitsData || []).map(h => normalizeHabitFromDB(h));

            // Load history entries
            let { data: historyData, error: historyError } = await supabase
                .from('history')
                .select('*');

            if (historyError) throw historyError;

            // Build history object: { 'YYYY-MM-DD': { habitId: { count, status } } }
            history = {};
            (historyData || []).forEach(row => {
                const dateKey = (row.date instanceof String) ? row.date : row.date; // date string
                const iso = new Date(row.date).toISOString().split('T')[0];
                if (!history[iso]) history[iso] = {};
                history[iso][String(row.habit_id)] = { count: row.count ?? 0, status: row.status ?? null, id: row.id };
            });

            // Persist a small local cache for faster UI loads (optional)
            localStorage.setItem('habits_cache', JSON.stringify(habits));
            localStorage.setItem('history_cache', JSON.stringify(history));
        } catch (err) {
            console.error('Error loading from Supabase:', err);
            // If Supabase fails, try to load caches
            const cachedHabits = localStorage.getItem('habits_cache');
            const cachedHistory = localStorage.getItem('history_cache');
            habits = cachedHabits ? JSON.parse(cachedHabits) : [];
            history = cachedHistory ? JSON.parse(cachedHistory) : {};
            showToast('Could not reach Supabase ‚Äî using local cache.');
        }
    }

    // Normalize habit from DB: ensure fields exist and UI-friendly keys
    function normalizeHabitFromDB(row) {
        return {
            id: row.id,
            name: row.name,
            category: row.category || '',
            goal: row.goal || 1,
            targetDays: Array.isArray(row.target_days) ? row.target_days : (row.target_days ? JSON.parse(row.target_days) : [0,1,2,3,4,5,6]),
            timeRange: row.time_range || 'Anytime',
            icon: row.icon || '‚ûï',
            color: row.color || '#F87171',
            creationDate: (row.creation_date) ? (new Date(row.creation_date).toISOString().split('T')[0]) : toISODateString(new Date())
        };
    }

    // Create a new habit in Supabase and local cache
    async function createHabitOnSupabase(habitData) {
        try {
            if (!navigator.onLine) {
                // Optimistic UI update
                const tempId = `temp-${Date.now()}`;
                const newHabit = { ...habitData, id: tempId };
                habits.push(newHabit);
                addToOfflineQueue({ type: 'CREATE_HABIT', payload: habitData });
                showToast("You're offline. Habit will be created when you're back.");
                return newHabit;
            }

            const insertRow = {
                name: habitData.name, category: habitData.category, goal: habitData.goal,
                target_days: habitData.targetDays, time_range: habitData.timeRange, icon: habitData.icon,
                color: habitData.color, creation_date: habitData.creationDate
            };
            const { data, error } = await supabase.from('habits').insert([insertRow]).select().single();
            if (error) throw error;

            const created = normalizeHabitFromDB(data);
            habits.push(created);
            localStorage.setItem('habits_cache', JSON.stringify(habits));
            return created;
        } catch (err) {
            console.error('Create habit error:', err);
            showToast('Failed to create habit.');
            return null;
        }
    }

    // Update habit in Supabase
    async function updateHabitOnSupabase(id, partial) {
        try {
            if (!navigator.onLine) {
                 const idx = habits.findIndex(h => h.id === id);
                if (idx > -1) {
                    habits[idx] = { ...habits[idx], ...partial, target_days: partial.target_days };
                }
                addToOfflineQueue({ type: 'UPDATE_HABIT', payload: { id, partial } });
                showToast("You're offline. Habit will be updated when you're back.");
                return habits[idx];
            }
            const { data, error } = await supabase.from('habits').update(partial).eq('id', id).select().single();
            if (error) throw error;

            const idx = habits.findIndex(h => h.id === id);
            if (idx > -1) habits[idx] = normalizeHabitFromDB(data);
            localStorage.setItem('habits_cache', JSON.stringify(habits));
            return habits[idx];
        } catch (err) {
            console.error('Update habit error:', err);
            showToast('Failed to update habit.');
            return null;
        }
    }

    // Delete habit and its history from Supabase
    async function deleteHabitOnSupabase(id) {
         try {
            if (!navigator.onLine) {
                habits = habits.filter(h => h.id !== id);
                addToOfflineQueue({ type: 'DELETE_HABIT', payload: { id } });
                 showToast("You're offline. Habit will be deleted when you're back.");
                return true;
            }
            await supabase.from('history').delete().eq('habit_id', id);
            const { error } = await supabase.from('habits').delete().eq('id', id);
            if (error) throw error;
            habits = habits.filter(h => h.id !== id);
            Object.keys(history).forEach(dateKey => { if (history[dateKey][String(id)]) delete history[dateKey][String(id)]; });
            localStorage.setItem('habits_cache', JSON.stringify(habits));
            localStorage.setItem('history_cache', JSON.stringify(history));
            return true;
        } catch (err) {
            console.error('Delete habit error:', err);
            showToast('Failed to delete habit.');
            return false;
        }
    }

    // Upsert a single history entry
    async function upsertHistoryEntryOnSupabase(habitId, isoDate, entry, isSyncing = false) {
        try {
            if (!navigator.onLine && !isSyncing) {
                 if (!history[isoDate]) history[isoDate] = {};
                history[isoDate][String(habitId)] = { ...entry, id: `temp-hist-${Date.now()}` };
                addToOfflineQueue({ type: 'UPSERT_HISTORY', payload: { habitId, isoDate, entry } });
                // No toast here to avoid spamming
                return;
            }
            
            const { data: existingRows } = await supabase.from('history').select('id').eq('habit_id', habitId).eq('date', isoDate);
            let updated;

            if (existingRows && existingRows.length > 0) {
                const { data, error } = await supabase.from('history').update({ count: entry.count, status: entry.status }).eq('id', existingRows[0].id).select().single();
                if (error) throw error;
                updated = data;
            } else {
                const { data, error } = await supabase.from('history').insert([{ habit_id: habitId, date: isoDate, status: entry.status, count: entry.count }]).select().single();
                if (error) throw error;
                updated = data;
            }

            if (!history[isoDate]) history[isoDate] = {};
            history[isoDate][String(habitId)] = { count: updated.count, status: updated.status, id: updated.id };
            localStorage.setItem('history_cache', JSON.stringify(history));
        } catch (err) {
            console.error('Upsert history error:', err);
             if (!isSyncing) showToast('Failed to sync history.');
        }
    }

    // Remove a history entry from Supabase
    async function removeHistoryEntryOnSupabase(habitId, isoDate, isSyncing = false) {
        try {
             if (!navigator.onLine && !isSyncing) {
                if (history[isoDate]) delete history[isoDate][String(habitId)];
                addToOfflineQueue({ type: 'REMOVE_HISTORY', payload: { habitId, isoDate } });
                // No toast here
                return;
            }
            const { error } = await supabase.from('history').delete().eq('habit_id', habitId).eq('date', isoDate);
            if (error) throw error;
            if (history[isoDate]) {
                delete history[isoDate][String(habitId)];
                if (Object.keys(history[isoDate]).length === 0) delete history[isoDate];
            }
            localStorage.setItem('history_cache', JSON.stringify(history));
        } catch (err) {
            console.error('Remove history error:', err);
            if(!isSyncing) showToast('Failed to remove history entry.');
        }
    }

    // -------------------------
    // UI render & interactions
    // -------------------------

    // Render date scroller
    function renderDateScroller() {
        dateScrollerContainer.innerHTML = '';
        const today = new Date();
        headerTitle.textContent = isSameDay(selectedDate, today) ? "Today" : selectedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

        for (let i = -14; i <= 14; i++) {
            const date = new Date();
            date.setDate(today.getDate() + i);
            const isSelected = isSameDay(date, selectedDate);

            const dateKey = toISODateString(date);
            const dayOfWeek = date.getDay();

            // Calculate progress for the day
            const activeHabits = habits.filter(h => new Date(h.creationDate) <= date && h.targetDays.includes(dayOfWeek));
            let progress = 0;
            if (activeHabits.length > 0) {
                const dayHistory = history[dateKey] || {};
                const completedCount = activeHabits.filter(h => {
                    const dayHistItem = dayHistory[String(h.id)];
                    return dayHistItem && dayHistItem.count >= h.goal && dayHistItem.status !== 'skipped';
                }).length;
                progress = (completedCount / activeHabits.length) * 100;
            }

            const radius = 16;
            const circumference = 2 * Math.PI * radius;
            const offset = circumference - (progress / 100) * circumference;

            const dateEl = document.createElement('button');
            
            dateEl.className = `
                flex flex-col items-center justify-center space-y-2 p-2 w-16 h-24 rounded-full flex-shrink-0 
                transition-all duration-300 ease-in-out
                dark:bg-[#1E1E1E] bg-gray-100
                border-2
                ${isSelected ? 'border-red-500' : 'border-transparent dark:border-transparent'}
            `;

            dateEl.innerHTML = `
                <span class="text-sm font-semibold ${isSelected ? 'text-red-500 dark:text-red-400' : 'text-gray-500 dark:text-gray-400'}">
                    ${date.toLocaleDateString('en-US', {weekday:'short'})}
                </span>
                <div class="relative w-10 h-10 flex items-center justify-center">
                    <svg class="absolute inset-0 w-full h-full" viewBox="0 0 36 36">
                        <circle class="stroke-current text-gray-300 dark:text-gray-700" cx="18" cy="18" r="${radius}" fill="none" stroke-width="2.5"></circle>
                        <circle class="stroke-current text-red-500 origin-center -rotate-90" cx="18" cy="18" r="${radius}" fill="none" stroke-width="2.5"
                            stroke-dasharray="${circumference}"
                            stroke-dashoffset="${offset}"
                            stroke-linecap="round"
                            style="transition: stroke-dashoffset 0.5s ease-in-out;"
                        ></circle>
                    </svg>
                    <span class="font-bold text-sm ${isSelected ? 'text-gray-900 dark:text-white' : 'text-gray-700 dark:text-gray-300'}">
                        ${date.getDate()}
                    </span>
                </div>
            `;

            dateEl.addEventListener('click', () => {
                selectedDate = date;
                renderDateScroller();
                renderHabits();
            });

            dateScrollerContainer.appendChild(dateEl);

            if (isSelected) {
                setTimeout(()=> dateEl.scrollIntoView({ behavior:'smooth', inline:'center', block: 'nearest' }), 100);
            }
        }
    }

    // Render habits for the currently selected date (uses local cache)
    function renderHabits() {
        const dateKey = toISODateString(selectedDate);
        const dayOfWeek = selectedDate.getDay();
        const today = new Date(); today.setHours(0,0,0,0);

        const allHabitsForDay = habits.filter(h => new Date(h.creationDate) <= selectedDate && h.targetDays.includes(dayOfWeek));

        const visibleHabits = allHabitsForDay.filter(h => {
            const hiddenDateStr = hiddenHabitsState[String(h.id)];
            if (!hiddenDateStr) return true;
            const hid = new Date(hiddenDateStr);
            return hid < today;
        });
        
        const isHabitCompleted = (habit, dateKey) => {
            const dayHist = history[dateKey] && history[dateKey][String(habit.id)];
            if (!dayHist || (dayHist && dayHist.status === 'skipped')) return false;
            return dayHist.count >= habit.goal;
        };
        visibleHabits.sort((a, b) => isHabitCompleted(a, dateKey) - isHabitCompleted(b, dateKey));

        const hiddenHabits = allHabitsForDay.filter(h => {
            const hiddenDateStr = hiddenHabitsState[String(h.id)];
            if (!hiddenDateStr) return false;
            const hid = new Date(hiddenDateStr);
            return hid >= today;
        });

        habitsContainer.innerHTML = '';
        if (visibleHabits.length === 0 && hiddenHabits.length === 0) {
            habitsContainer.innerHTML = `<div class="text-center mt-20 flex flex-col items-center"><div class="w-40 h-40 opacity-30"></div><h2 class="text-xl font-bold mt-4">No Habits Today</h2><p class="text-gray-500 dark:text-gray-400 mt-1">Tap "+" to add a new habit.</p></div>`;
        } else if (visibleHabits.length === 0) {
            habitsContainer.innerHTML = `<div class="text-center mt-20 text-gray-500 dark:text-gray-400">All habits for today are hidden.</div>`;
        }
        
        let separatorAdded = false;
        const firstCompletedIndex = visibleHabits.findIndex(h => isHabitCompleted(h, dateKey));

        visibleHabits.forEach(habit => {
            const dayHist = (history[dateKey] && history[dateKey][String(habit.id)]);
            const isSkipped = dayHist && dayHist.status === 'skipped';
            const currentCount = dayHist ? dayHist.count : 0;
            const completed = !isSkipped && currentCount >= habit.goal;

            if (completed && !separatorAdded && firstCompletedIndex !== -1) {
                const separator = document.createElement('div');
                separator.className = 'flex items-center my-4';
                separator.innerHTML = `
                    <hr class="flex-grow border-gray-300 dark:border-gray-700">
                    <span class="mx-4 text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wider">Completed</span>
                    <hr class="flex-grow border-gray-300 dark:border-gray-700">
                `;
                habitsContainer.appendChild(separator);
                separatorAdded = true;
            }
            
            const progressPercentage = isSkipped ? 100 : Math.min((currentCount / habit.goal) * 100, 100);

            const wrapper = document.createElement('div');
            wrapper.className = 'habit-swipe-container';
            
            let mainColor, darkColor;
            if (completed) {
                mainColor = '#4ADE80'; // green-400
                darkColor = '#166534'; // green-800
            } else if (isSkipped) {
                mainColor = '#A1A1AA'; // zinc-400
                darkColor = '#3F3F46'; // zinc-700
            } else {
                const colorPair = COLORS.find(c => c.main === habit.color) || COLORS[3];
                mainColor = colorPair.main;
                darkColor = colorPair.dark;
            }

            const backgroundStyle = `background: linear-gradient(to right, ${mainColor} ${progressPercentage}%, ${darkColor} ${progressPercentage}%);`;

            wrapper.innerHTML = `
                <div class="habit-actions">
                    <button data-action="skip" class="habit-action-btn bg-orange-500"><svg class="w-6 h-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"/></svg>Skip</button>
                    <button data-action="hide" class="habit-action-btn bg-blue-700"><svg class="w-6 h-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a9.97 9.97 0 01-1.563 3.029m0 0l-3.59-3.59"/></svg>Hide</button>
                    <button data-action="reset" class="habit-action-btn bg-teal-500"><svg class="w-6 h-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20v-5h-5M4 4l5 5M20 20l-5-5"/></svg>Reset</button>
                </div>
                <div class="habit-content p-4 rounded-xl flex items-center gap-4 ${completed ? 'opacity-100' : ''}" style="${backgroundStyle}">
                    <div class="text-2xl">${habit.icon}</div>
                    <div class="flex-grow">
                        <p class="font-semibold text-white">${habit.name}</p>
                    </div>
                    <div class="text-center">
                        <p class="font-semibold text-sm text-white/80">${isSkipped ? 'Skipped' : `${currentCount}/${habit.goal}`}</p>
                    </div>
                    <div class="completion-checkmark text-2xl text-white transition-opacity duration-500 ${completed ? 'opacity-100' : 'opacity-0'}">‚úÖ</div>
                    <button class="options-btn p-2 -mr-2 flex-shrink-0" data-habit-id="${habit.id}"><svg class="w-6 h-6 text-white/70 pointer-events-none" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 12.75a.75.75 0 110-1.5.75.75 0 010 1.5zM12 18.75a.75.75 0 110-1.5.75.75 0 010 1.5z" /></svg></button>
                </div>
            `;

            const habitContent = wrapper.querySelector('.habit-content');
            addSwipeListeners(habit, habitContent, dateKey);

            habitContent.addEventListener('click', async (e) => {
                if (e.target.closest('.options-btn')) return;
                 if (completed && !e.target.closest('.options-btn')) {
                    showToast('Habit already completed! Reset to change.');
                    return;
                }
                // Increment count for this habit/day
                if (!history[dateKey]) history[dateKey] = {};
                const current = (history[dateKey][String(habit.id)] ? history[dateKey][String(habit.id)].count : 0) + 1;
                if (current <= habit.goal) {
                    history[dateKey][String(habit.id)] = { count: current, status: null };
                    await upsertHistoryEntryOnSupabase(habit.id, dateKey, { count: current, status: null });
                    renderHabits();
                }
            });

            habitsContainer.appendChild(wrapper);
        });

        renderHiddenHabits(hiddenHabits);
    }

    function renderHiddenHabits(hiddenHabits) {
        if (hiddenHabits.length > 0) {
            hiddenHabitsSection.classList.remove('hidden');
            hiddenHabitsList.innerHTML = hiddenHabits.map(habit => `
                <div class="hidden-habit-swipe-container" data-habit-id="${habit.id}">
                    <div class="hidden-habit-tile bg-gray-300 dark:bg-gray-800 p-2 rounded-lg flex items-center justify-between opacity-70">
                        <div class="flex items-center gap-3">
                           <span class="text-xl">${habit.icon}</span>
                           <span class="text-sm font-semibold">${habit.name}</span>
                        </div>
                        <button class="unhide-btn text-xs font-bold text-blue-600 dark:text-blue-400 p-2">UNHIDE</button>
                    </div>
                </div>
            `).join('');

            // add listeners
            hiddenHabitsList.querySelectorAll('.unhide-btn').forEach(btn => {
                const habitId = parseInt(btn.closest('.hidden-habit-swipe-container').dataset.habitId);
                btn.addEventListener('click', () => {
                    unhideHabit(habitId);
                });
            });

            hiddenHabitsList.querySelectorAll('.hidden-habit-tile').forEach(tile => {
                addUnhideSwipeListener(tile);
            });
        } else {
            hiddenHabitsSection.classList.add('hidden');
        }
    }

    // Stats & achievements rendering (kept mostly the same)
    function renderTodaysProgress() {
        const today = new Date();
        const dateKey = toISODateString(today);
        const dayOfWeek = today.getDay();
        const activeHabits = habits.filter(h => new Date(h.creationDate) <= today && h.targetDays.includes(dayOfWeek));
        if (activeHabits.length === 0) return '';

        const todaysHistory = history[dateKey] || {};
        const completedCount = activeHabits.filter(h => (todaysHistory[String(h.id)] && todaysHistory[String(h.id)].count >= h.goal)).length;
        const progress = activeHabits.length > 0 ? Math.round((completedCount / activeHabits.length) * 100) : 0;

        return `
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h3 class="font-bold mb-2">Today's Progress</h3>
                <div class="flex items-center gap-4">
                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                        <div class="bg-green-500 h-2.5 rounded-full" style="width: ${progress}%"></div>
                    </div>
                    <span class="font-semibold text-lg">${progress}%</span>
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">${completedCount} of ${activeHabits.length} habits completed.</p>
            </div>
        `;
    }

    function renderWeeklyOverview() {
        let weeklyContent = '';
        const today = new Date();
        for (let i = 6; i >= 0; i--) {
            const date = new Date();
            date.setDate(today.getDate() - i);
            const dateKey = toISODateString(date);
            const dayOfWeek = date.getDay();
            const activeHabits = habits.filter(h => new Date(h.creationDate) <= date && h.targetDays.includes(dayOfWeek));
            let progress = 0;
            if (activeHabits.length > 0) {
                const dayHistory = history[dateKey] || {};
                const completedCount = activeHabits.filter(h => (dayHistory[String(h.id)] && dayHistory[String(h.id)].count >= h.goal)).length;
                progress = (completedCount / activeHabits.length) * 100;
            }
            weeklyContent += `
                <div class="flex flex-col items-center gap-2">
                    <div class="w-full h-32 bg-gray-200 dark:bg-gray-800 rounded-md flex items-end">
                        <div class="w-full bg-teal-500 rounded-md" style="height: ${progress}%"></div>
                    </div>
                    <span class="text-xs font-medium text-gray-500 dark:text-gray-400">${date.toLocaleDateString('en-us', {weekday:'short'})}</span>
                </div>
            `;
        }
        return `
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h3 class="font-bold mb-3">Weekly Overview</h3>
                <div class="grid grid-cols-7 gap-3">${weeklyContent}</div>
            </div>
        `;
    }

    function renderMonthlyOverview() {
        const today = new Date();
        const month = today.getMonth();
        const year = today.getFullYear();
        const firstDayOfMonth = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        let daysContent = Array(firstDayOfMonth.getDay()).fill(`<div class="w-8 h-8"></div>`).join('');

        for (let day = 1; day <= daysInMonth; day++) {
            const date = new Date(year, month, day);
            const dateKey = toISODateString(date);
            const dayOfWeek = date.getDay();
            const activeHabits = habits.filter(h => new Date(h.creationDate) <= date && h.targetDays.includes(dayOfWeek));
            let completionRate = 0;
            let bgColor = 'bg-gray-200 dark:bg-gray-800';

            if (activeHabits.length > 0) {
                const dayHistory = history[dateKey] || {};
                const completedCount = activeHabits.filter(h => (dayHistory[String(h.id)] && dayHistory[String(h.id)].count >= h.goal)).length;
                completionRate = completedCount / activeHabits.length;
            } else if (date < today) {
                bgColor = 'bg-gray-200/50 dark:bg-gray-800/50';
            }

            if (completionRate > 0) bgColor = 'bg-red-200 dark:bg-red-800/70';
            if (completionRate >= 0.5) bgColor = 'bg-yellow-200 dark:bg-yellow-800/70';
            if (completionRate === 1) bgColor = 'bg-green-200 dark:bg-green-800/70';

            daysContent += `<div class="w-8 h-8 flex items-center justify-center text-xs rounded-md ${bgColor}">${day}</div>`;
        }

        return `
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h3 class="font-bold mb-3">${today.toLocaleString('default', { month: 'long' })} Overview</h3>
                <div class="grid grid-cols-7 gap-2 text-center">
                    <div class="text-xs text-gray-500 dark:text-gray-400">S</div><div class="text-xs text-gray-500 dark:text-gray-400">M</div><div class="text-xs text-gray-500 dark:text-gray-400">T</div><div class="text-xs text-gray-500 dark:text-gray-400">W</div><div class="text-xs text-gray-500 dark:text-gray-400">T</div><div class="text-xs text-gray-500 dark:text-gray-400">F</div><div class="text-xs text-gray-500 dark:text-gray-400">S</div>
                    ${daysContent}
                </div>
            </div>
        `;
    }

    function calculateStreak(habitId) {
        let currentStreak = 0;
        let checkDate = new Date();
        const habit = habits.find(h => h.id === habitId);
        if (!habit) return 0;
        while (new Date(habit.creationDate) <= checkDate) {
            const dateKey = toISODateString(checkDate);
            const dayOfWeek = checkDate.getDay();
            if (habit.targetDays.includes(dayOfWeek)) {
                const dayHistory = history[dateKey];
                if (dayHistory && (dayHistory[String(habitId)] && dayHistory[String(habitId)].count >= habit.goal)) {
                    currentStreak++;
                } else if (!dayHistory || (dayHistory[String(habitId)] && dayHistory[String(habitId)].status === 'skipped')) {
                    // do nothing, skip does not break streak per earlier logic
                    break;
                } else {
                    break;
                }
            }
            checkDate.setDate(checkDate.getDate() - 1);
        }
        return currentStreak;
    }

    function renderHabitPerformance() {
        if (habits.length === 0) return '';
        let performanceContent = habits.map(habit => {
            const streak = calculateStreak(habit.id);
            const totalCompletions = Object.values(history).reduce((acc, day) => acc + ((day[String(habit.id)] && day[String(habit.id)].count >= habit.goal) ? 1 : 0), 0);
            return `
                <div class="p-4 rounded-xl flex items-center gap-4 bg-gray-200/50 dark:bg-gray-800/50">
                    <div class="text-3xl">${habit.icon}</div>
                    <div class="flex-grow">
                        <p class="font-bold">${habit.name}</p>
                        <p class="text-sm text-gray-600 dark:text-gray-400">Total Completions: ${totalCompletions}</p>
                    </div>
                    <div class="text-center">
                        <p class="text-2xl font-bold text-orange-500 dark:text-orange-400">${streak}</p>
                        <p class="text-xs text-gray-600 dark:text-gray-400">Day Streak</p>
                    </div>
                </div>
            `;
        }).join('');
        return `
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h3 class="font-bold mb-3">Habit Performance</h3>
                <div class="space-y-3">${performanceContent}</div>
            </div>
        `;
    }

    function renderStatsView() {
        const container = document.getElementById('stats-container');
        if (habits.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 mt-10">Start tracking habits to see your stats!</p>`;
            return;
        }
        container.innerHTML = `
            ${renderTodaysProgress()}
            ${renderWeeklyOverview()}
            ${renderMonthlyOverview()}
            ${renderHabitPerformance()}
        `;
    }

    function getAchievements() {
        const totalCompletions = Object.values(history).reduce((sum, day) => sum + Object.values(day).filter(d => typeof d.count === 'number' && d.count > 0).length, 0);
        const maxStreak = Math.max(0, ...habits.map(h => calculateStreak(h.id)));
        const earlyRiserHabits = habits.filter(h => h.timeRange === 'Morning').length;
        const totalGoalsMet = Object.values(history).reduce((sum, day) => {
            return sum + Object.keys(day).filter(habitId => {
                const habit = habits.find(h => h.id == habitId);
                return habit && day[habitId] && day[habitId].count >= habit.goal;
            }).length;
        }, 0);

        return [
            { id: 'streak7', title: '7-Day Streak', icon: 'üî•', unlocked: maxStreak >= 7 },
            { id: 'streak30', title: '30-Day Streak', icon: 'üåü', unlocked: maxStreak >= 30 },
            { id: 'earlyRiser', title: 'Early Riser', icon: 'üåÖ', unlocked: earlyRiserHabits > 0 && totalCompletions > 5 },
            { id: 'consistency', title: 'Consistency Champ', icon: 'üéØ', unlocked: totalCompletions >= 50 },
            { id: 'goalMaster', title: 'Goal Master', icon: 'üëë', unlocked: totalGoalsMet >= 100 },
            { id: 'firstHabit', title: 'First Step', icon: 'üå±', unlocked: habits.length > 0 },
            { id: 'fiveHabits', title: 'Habit Builder', icon: 'üèóÔ∏è', unlocked: habits.length >= 5 },
            { id: 'perfectDay', title: 'Perfect Day', icon: '‚úÖ', unlocked: Object.values(history).some(day => {
                const dateKey = Object.keys(history).find(k => history[k] === day);
                if (!dateKey) return false;
                const dayDate = new Date(dateKey);
                const activeHabits = habits.filter(h => h.targetDays.includes(dayDate.getUTCDay()));
                return activeHabits.length > 0 && activeHabits.every(h => (day[String(h.id)] && day[String(h.id)].count >= h.goal));
            })}
        ];
    }

    function renderAchievementsView() {
        const container = document.getElementById('achievements-container');
        const achievements = getAchievements();
        const unlockedCount = achievements.filter(a => a.unlocked).length;
        const progress = (unlockedCount / achievements.length) * 100;

        let badgesHTML = achievements.map(ach => `
            <div class="flex flex-col items-center text-center p-4 rounded-xl ${ach.unlocked ? 'bg-amber-400/10 dark:bg-amber-900/40 achievement-unlocked' : 'bg-gray-200 dark:bg-gray-800 opacity-60'}">
                <div class="text-4xl mb-2">${ach.unlocked ? ach.icon : 'üîí'}</div>
                <h4 class="font-bold text-sm">${ach.title}</h4>
            </div>
        `).join('');

        container.innerHTML = `
            <div class="bg-white dark:bg-[#1E1E1E] p-4 rounded-xl">
                <h3 class="font-bold mb-2">Next Reward</h3>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                    <div class="bg-gradient-to-r from-yellow-400 to-orange-500 h-4 rounded-full text-xs text-black font-bold flex items-center justify-center" style="width: ${progress}%">
                       Level ${Math.floor(unlockedCount / 2) + 1}
                    </div>
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400 mt-2 text-center">${unlockedCount} / ${achievements.length} Unlocked</p>
            </div>
            <div class="grid grid-cols-3 gap-4">
                ${badgesHTML}
            </div>
        `;
    }

    // -------------------------
    // Form interactions
    // -------------------------
    const openAddHabitView = (habitToEdit = null) => {
        currentEditingHabitId = habitToEdit ? habitToEdit.id : null;
        formTitle.textContent = habitToEdit ? 'Edit Habit' : 'Create Habit';
        saveHabitBtn.textContent = habitToEdit ? 'Save Changes' : 'Create Habit';

        habitNameInput.value = habitToEdit ? habitToEdit.name : '';
        habitCategoryInput.value = habitToEdit ? habitToEdit.category : '';
        habitTimesPerDayInput.value = habitToEdit ? habitToEdit.goal : '1';
        iconPreviewButton.textContent = habitToEdit ? habitToEdit.icon : '‚ûï';

        const targetDays = habitToEdit ? habitToEdit.targetDays : [0,1,2,3,4,5,6];
        formTargetDays.innerHTML = DAYS_OF_WEEK.map((day,index) => `<button class="day-btn w-10 h-10 rounded-full text-sm bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-300 ${targetDays.includes(index)?'active':''}" data-day="${index}">${day}</button>`).join('');

        const timeRange = habitToEdit ? habitToEdit.timeRange : 'Anytime';
        formTimeRange.innerHTML = TIME_RANGES.map(range => `<button class="time-range-btn flex-1 py-2 px-3 text-sm rounded-lg bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-300 ${timeRange===range ? 'active' : ''}" data-range="${range}">${range}</button>`).join('');

        let selectedColor = habitToEdit ? habitToEdit.color : COLORS[3].main;
        formColorGrid.innerHTML = COLORS.map(c => `<button class="w-8 h-8 rounded-full ${selectedColor===c.main ? 'ring-2 ring-offset-2 ring-white dark:ring-offset-[#1E1E1E] ring-current' : ''}" style="background-color: ${c.main}" data-main="${c.main}" data-dark="${c.dark}"></button>`).join('');

        addHabitView.classList.remove('translate-x-full');
    };

    formTargetDays.addEventListener('click', e => { if (e.target.matches('.day-btn')) e.target.classList.toggle('active'); });
    formTimeRange.addEventListener('click', e => { if (e.target.matches('.time-range-btn')) { formTimeRange.querySelectorAll('.time-range-btn').forEach(btn=>btn.classList.remove('active')); e.target.classList.add('active'); }});
    formColorGrid.addEventListener('click', e => {
        if (e.target.dataset && e.target.dataset.main) {
            formColorGrid.querySelectorAll('button').forEach(btn => btn.classList.remove('ring-2','ring-offset-2','ring-white','dark:ring-offset-[#1E1E1E]','ring-current'));
            e.target.classList.add('ring-2','ring-offset-2','ring-white','dark:ring-offset-[#1E1E1E]','ring-current');
        }
    });

    saveHabitBtn.addEventListener('click', async () => {
        const name = habitNameInput.value.trim();
        const category = habitCategoryInput.value.trim();
        const goal = parseInt(habitTimesPerDayInput.value, 10);
        const selectedDays = [...formTargetDays.querySelectorAll('.day-btn.active')].map(btn => parseInt(btn.dataset.day));
        if (!name || !goal || goal < 1 || selectedDays.length === 0) {
            showToast("Please fill all fields and select at least one day.");
            return;
        }
        const selectedColorEl = formColorGrid.querySelector('.ring-2');
        const color = selectedColorEl ? selectedColorEl.dataset.main : COLORS[3].main;
        const icon = iconPreviewButton.textContent;
        const timeRange = formTimeRange.querySelector('.time-range-btn.active').dataset.range;
        const creationDate = toISODateString(new Date());

        const habitData = { name, category, goal, targetDays: selectedDays, timeRange, icon, color, creationDate };

        if (currentEditingHabitId) {
            const partial = {
                name, category, goal, target_days: selectedDays, time_range: timeRange, icon, color
            };
            await updateHabitOnSupabase(currentEditingHabitId, partial);
            showToast('Habit updated.');
        } else {
            const created = await createHabitOnSupabase(habitData);
            if (created) showToast('Habit created.');
        }

        renderHabits();
        renderDateScroller();
        addHabitView.classList.add('translate-x-full');
    });

    // Swipe logic for actions
    function addSwipeListeners(habit, element, dateKey) {
        let startX = 0, currentX = 0, isDragging = false;
        const maxDrag = 210; // 3 buttons * 70px
        function dragStart(e) {
            startX = e.touches ? e.touches[0].clientX : e.clientX;
            currentX = startX; isDragging = true; element.style.transition = 'none';
            document.addEventListener('mousemove', dragMove); document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchmove', dragMove, { passive: true }); document.addEventListener('touchend', dragEnd);
        }
        function dragMove(e) {
            if (!isDragging) return; e.preventDefault();
            currentX = e.touches ? e.touches[0].clientX : e.clientX;
            let diff = currentX - startX; if (diff > 0) diff = 0; if (diff < -maxDrag) diff = -maxDrag;
            element.style.transform = `translateX(${diff}px)`;
        }
        function dragEnd() {
            if (!isDragging) return;
            isDragging = false;
            document.removeEventListener('mousemove', dragMove); document.removeEventListener('mouseup', dragEnd);
            document.removeEventListener('touchmove', dragMove); document.removeEventListener('touchend', dragEnd);
            element.style.transition = 'transform 0.3s ease-out';
            const diff = currentX - startX;
            if (diff < -50) {
                element.style.transform = `translateX(-${maxDrag}px)`;
            } else {
                element.style.transform = 'translateX(0px)';
            }
        }
        element.addEventListener('mousedown', dragStart);
        element.addEventListener('touchstart', dragStart, { passive: true });

        const parent = element.parentElement;
        parent.querySelector('[data-action="skip"]').addEventListener('click', async () => {
            const iso = dateKey;
            if (!history[iso]) history[iso] = {};
            history[iso][String(habit.id)] = { count: 0, status: 'skipped' };
            await upsertHistoryEntryOnSupabase(habit.id, iso, { count: 0, status: 'skipped' });
            renderHabits();
            showToast(`'${habit.name}' skipped for ${iso}.`);
        });

        parent.querySelector('[data-action="hide"]').addEventListener('click', () => {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const iso = toISODateString(tomorrow);
            
            hiddenHabitsState[String(habit.id)] = iso;
            localStorage.setItem('hidden_habits_state', JSON.stringify(hiddenHabitsState));
            
            renderHabits();
            showToast(`'${habit.name}' hidden until tomorrow.`);
        });

        parent.querySelector('[data-action="reset"]').addEventListener('click', async () => {
            const iso = dateKey;
            if (history[iso] && history[iso][String(habit.id)]) {
                await removeHistoryEntryOnSupabase(habit.id, iso);
                renderHabits();
                showToast(`'${habit.name}' progress reset for ${iso}.`);
            } else {
                showToast('No progress to reset for this habit today.');
                element.style.transform = 'translateX(0px)';
            }
        });
    }

    const unhideHabit = (habitId) => {
        delete hiddenHabitsState[String(habitId)];
        localStorage.setItem('hidden_habits_state', JSON.stringify(hiddenHabitsState));
        renderHabits();
        showToast('Habit is now visible.');
    };

    function addUnhideSwipeListener(element) {
        let startX = 0, currentX = 0, isDragging = false;
        function dragStart(e) {
            startX = e.touches ? e.touches[0].clientX : e.clientX;
            currentX = startX; isDragging = true; element.style.transition = 'none';
            document.addEventListener('mousemove', dragMove); document.addEventListener('mouseup', dragEnd);
            document.addEventListener('touchmove', dragMove, { passive: true }); document.addEventListener('touchend', dragEnd);
        }
        function dragMove(e) {
            if (!isDragging) return; e.preventDefault();
            currentX = e.touches ? e.touches[0].clientX : e.clientX;
            let diff = currentX - startX; if (diff < 0) diff = 0;
            element.style.transform = `translateX(${diff}px)`;
        }
        function dragEnd() {
            if (!isDragging) return;
            isDragging = false; document.removeEventListener('mousemove', dragMove); document.removeEventListener('mouseup', dragEnd);
            document.removeEventListener('touchmove', dragMove); document.removeEventListener('touchend', dragEnd);
            element.style.transition = 'transform 0.3s ease-out';
            const habitId = parseInt(element.closest('.hidden-habit-swipe-container').dataset.habitId);
            const diff = currentX - startX;
            if (diff > 50) unhideHabit(habitId); else element.style.transform = 'translateX(0)';
        }
        element.addEventListener('mousedown', dragStart);
        element.addEventListener('touchstart', dragStart, { passive: true });
    }

    // -------------------------
    // Initialization & events
    // -------------------------
    // Theme apply
    const applyTheme = (theme) => {
        if (theme === 'light') document.documentElement.classList.remove('dark'); else document.documentElement.classList.add('dark');
        localStorage.setItem('theme', theme);
        updateThemeToggleUI(theme);
    };
    const updateThemeToggleUI = (theme) => {
        themeSelector.querySelectorAll('.theme-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme));
    };

    // Load offline queue
    offlineQueue = JSON.parse(localStorage.getItem('offlineQueue')) || [];
    
    // Listen for online/offline events
    window.addEventListener('online', syncOfflineActions);


    // Load data from Supabase on start
    await loadDataFromSupabase();

    // Load hidden state from local storage
    const savedHiddenState = localStorage.getItem('hidden_habits_state');
    if (savedHiddenState) {
        hiddenHabitsState = JSON.parse(savedHiddenState);
    }

    // Initialize Theme
    const savedTheme = localStorage.getItem('theme') || 'dark';
    applyTheme(savedTheme);

    renderDateScroller();
    renderHabits();
    
    // Sync any pending changes if online
    if (navigator.onLine) {
        syncOfflineActions();
    }

    // Navigation
    document.querySelectorAll('.nav-btn[data-view]').forEach(btn => {
        btn.addEventListener('click', () => {
            showView(btn.dataset.view);
        });
    });

    function showView(viewId) {
        appContainer.querySelectorAll('.view').forEach(v => v.classList.add('hidden'));
        document.getElementById(viewId).classList.remove('hidden');

        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.classList.toggle('text-red-500', btn.dataset.view === viewId);
            const isInactive = btn.dataset.view !== viewId;
            btn.classList.toggle('text-gray-500', isInactive);
            btn.classList.toggle('dark:text-gray-400', isInactive);
        });

        if (viewId === 'stats-view') renderStatsView();
        if (viewId === 'achievements-view') renderAchievementsView();
    }

    // Add habit btn
    document.getElementById('add-habit-btn').addEventListener('click', () => openAddHabitView());
    backBtn.addEventListener('click', () => addHabitView.classList.add('translate-x-full'));

    // Context menu
    habitsContainer.addEventListener('click', e => {
        const optionsBtn = e.target.closest('.options-btn');
        if (optionsBtn) {
            const habitId = parseInt(optionsBtn.dataset.habitId);
            currentEditingHabitId = habitId;
            showModal(contextMenuModal);
        }
    });

    document.getElementById('close-context-menu').addEventListener('click', () => hideModal(contextMenuModal));
    document.getElementById('edit-habit-btn').addEventListener('click', async () => {
        hideModal(contextMenuModal);
        const habitToEdit = habits.find(h => h.id === currentEditingHabitId);
        if (habitToEdit) openAddHabitView(habitToEdit);
    });

    document.getElementById('delete-habit-btn').addEventListener('click', () => {
        hideModal(contextMenuModal);
        showConfirmation('Delete Habit', 'Are you sure you want to delete this habit and all its history?', async () => {
            await deleteHabitOnSupabase(currentEditingHabitId);
            renderHabits();
            renderDateScroller();
            showToast('Habit deleted.');
        });
    });

    // Icon picker
    iconGrid.innerHTML = ICONS.map(icon => `<button class="text-3xl p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700" data-icon="${icon}">${icon}</button>`).join('');
    iconPreviewButton.addEventListener('click', () => showModal(iconPickerModal));
    document.getElementById('close-icon-modal').addEventListener('click', () => hideModal(iconPickerModal));
    iconGrid.addEventListener('click', (e) => {
        if (e.target.dataset.icon) {
            iconPreviewButton.textContent = e.target.dataset.icon;
            hideModal(iconPickerModal);
        }
    });

    // Reset all data
    document.getElementById('reset-data-btn').addEventListener('click', () => {
        showConfirmation('Reset All Data', 'This is irreversible. All your habits and progress will be lost from Supabase and local cache.', async () => {
            try {
                if(navigator.onLine) {
                    let { error: historyError } = await supabase.from('history').delete().neq('id', -1);
                    if (historyError) throw historyError;
                    let { error: habitsError } = await supabase.from('habits').delete().neq('id', -1);
                    if (habitsError) throw habitsError;
                }
            } catch (err) {
                console.error('Reset error:', err);
            }
            habits = []; history = {}; hiddenHabitsState = {}; offlineQueue = [];
            localStorage.removeItem('habits_cache'); 
            localStorage.removeItem('history_cache');
            localStorage.removeItem('hidden_habits_state');
            localStorage.removeItem('offlineQueue');
            renderHabits();
            renderDateScroller();
            showToast('All data has been reset.');
        });
    });

    themeSelector.addEventListener('click', (e) => {
        if (e.target.matches('.theme-btn')) applyTheme(e.target.dataset.theme);
    });

    // Hidden habits toggle
    hiddenHabitsHeader.addEventListener('click', () => {
        const isExpanded = hiddenHabitsList.classList.contains('expanded');
        if (isExpanded) {
            hiddenHabitsList.style.maxHeight = '0'; hiddenHabitsList.style.padding = '0'; hiddenHabitsArrow.style.transform = 'rotate(0deg)';
        } else {
            hiddenHabitsList.style.maxHeight = '200px'; hiddenHabitsList.style.padding = '1rem'; hiddenHabitsArrow.style.transform = 'rotate(180deg)';
        }
        hiddenHabitsList.classList.toggle('expanded');
    });

     // Service Worker Registration
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./service-worker-habit.js')
                .then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                })
                .catch(error => {
                    console.log('ServiceWorker registration failed: ', error);
                });
        });
    }


}); // end DOMContentLoaded
</script>
</body>
</html>

