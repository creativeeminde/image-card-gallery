<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="robots" content="noindex, nofollow">
  <link rel="icon" href="https://ik.imagekit.io/xfifcyvcg/P_icon.ico?updatedAt=1748049193174" type="image/x-icon">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Model Gallery | Visual Search</title>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- START: Added Masonry & imagesLoaded -->
  <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
  <!-- END: Added Masonry & imagesLoaded -->
  <style>
    /* Custom scrollbar for a cleaner look */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    ::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Simple loading spinner */
    .loader {
      border: 4px solid #333;
      border-top: 4px solid #999;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Custom context menu */
    #context-menu {
      display: none;
      position: fixed;
      z-index: 1000;
      background-color: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #context-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      background: none;
      border: none;
      color: #e0e0e0;
      text-align: left;
      border-radius: 4px;
      cursor: pointer;
    }
    #context-menu button:hover {
      background-color: #3b82f6; /* Tailwind blue-500 */
      color: white;
    }
    
    /* Style for the new sort dropdown */
    #sort-order {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor' aria-hidden='true'%3e%3cpath fill-rule='evenodd' d='M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.7 9.24a.75.75 0 011.1 1.02L10 15.148l2.7-2.888a.75.75 0 111.1 1.02l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 010-1.02z' clip-rule='evenodd'/%3e%3c/svg%3e");
      background-size: 1.25rem;
      background-repeat: no-repeat;
      background-position: right 0.5rem center;
      padding-right: 2.25rem; /* Make space for icon */
    }
    
    /* Masonry Layout */
    #gallery {
      /* Reverted back to column-count for masonry layout */
      /* REMOVED: column-count, column-gap. Masonry.js will handle this. */
      position: relative; /* Required for Masonry.js positioning */
    }
    /*
    @media (min-width: 768px) { 
      #gallery { column-count: 3; }
    }
    @media (min-width: 1024px) { 
      #gallery { column-count: 4; }
    }
    @media (min-width: 1280px) { 
      #gallery { column-count: 5; }
    }
    @media (min-width: 1536px) { 
      #gallery { column-count: 6; }
    }
    */
    
    .masonry-item {
      /* Re-instated properties for masonry items */
      /* REMOVED: display: inline-block; */
      /* UPDATED: Widths for Masonry.js to calculate columns using calc() for fixed margins */
      width: calc(50% - 8px); /* 2 cols. 4px margin L/R on each item = 8px total per item */
      margin-bottom: 8px; 
      margin-left: 4px;
      margin-right: 4px;
      /* REMOVED: break-inside: avoid; */
    }
    /* UPDATED: Responsive widths for Masonry.js with calc() */
    @media (min-width: 768px) { /* md */
      .masonry-item { width: calc(33.333% - 8px); } /* 3 cols */
    }
    @media (min-width: 1024px) { /* lg */
      .masonry-item { width: calc(25% - 8px); } /* 4 cols */
    }
    @media (min-width: 1280px) { /* xl */
      .masonry-item { width: calc(20% - 8px); } /* 5 cols */
    }
    @media (min-width: 1536px) { /* 2xl */
      .masonry-item { width: calc(16.666% - 8px); } /* 6 cols */
    }
    

    /* Card item hover effect (renamed from .grid-item) */
    .masonry-item .overlay {
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }
    .masonry-item:hover .overlay {
      opacity: 1;
    }
    
    /* Viewer Zoom/Pan Styles */
    #viewer-image-container {
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
      position: relative; /* For image positioning */
    }
    #viewer-image-container.grabbing {
      cursor: grabbing;
    }
    #viewer-image {
      transform-origin: center center;
      transition: transform 0.1s ease-out;
      position: absolute; /* Allows for centering */
      top: 50%;
      left: 50%;
      will-change: transform; /* Hint for browser performance */
    }
    
    /* Masonry Layout for Related Grid */
    #viewer-related-grid {
      column-count: 2;
      column-gap: 4px; /* Tailwind gap-1 */
    }
    @media (min-width: 768px) { /* md */
      #viewer-related-grid { 
        column-count: 3; 
        column-gap: 8px; /* Tailwind gap-2 */
      }
    }
    
    .related-masonry-item {
      display: inline-block;
      width: 100%;
      margin-bottom: 8px; /* Match main gallery gap */
      break-inside: avoid;
    }
  </style>
</head>
<body class="bg-black text-gray-300 font-sans antialiased">

  <!-- Header Navigation -->
  <header class="fixed top-0 left-0 right-0 z-50 bg-black bg-opacity-80 backdrop-blur-sm">
    <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
      <div class="flex items-center space-x-6">
        <a href="#" onclick="showAllModels(event)" class="text-lg font-semibold text-white hover:text-gray-300">Home</a>
        
        <!-- START: New Total Count Element -->
        <span class="text-sm text-gray-500" id="total-card-count">(...)</span>
        <!-- END: New Total Count Element -->
        
        <a href="#" onclick="showFavorites(event)" class="text-sm text-gray-400 hover:text-white">Favorites</a>
        <a href="#" onclick="showNsfw(event)" id="nsfwBtn" class="text-sm text-gray-400 hover:text-white">NSFW</a>
        
        <!-- Tags Dropdown -->
        <div class="relative" id="tags-dropdown-container">
          <button onclick="toggleTagsDropdown(event)" id="tags-dropdown-btn" class="text-sm text-gray-400 hover:text-white focus:outline-none">
            Tags
          </button>
          <div id="tags-dropdown-menu" class="hidden absolute top-full left-0 mt-2 w-56 bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10 py-2 max-h-64 overflow-y-auto">
            <!-- JS will populate this -->
            <span class="block px-4 py-2 text-sm text-gray-500">Loading...</span>
          </div>
        </div>
        <!-- END Tags Dropdown -->
        
        <!-- START: Sort Order Dropdown -->
        <div class="relative">
          <select id="sort-order" class="text-sm text-gray-400 hover:text-white focus:outline-none bg-transparent border-0 focus:ring-0">
            <option value="last_uploaded" class="bg-gray-800">Last uploaded</option>
            <option value="first_uploaded" class="bg-gray-800">First uploaded</option>
            <option value="shuffle" class="bg-gray-800">Shuffle</option>
          </select>
        </div>
        <!-- END: Sort Order Dropdown -->
        
      </div>
      <button onclick="openPopup()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">
        Upload
      </button>
    </nav>
  </header>

  <!-- Main Content Area -->
  <main class="pt-24 pb-12 px-4 md:px-6">
    
    <!-- Search/Filter Status -->
    <div id="search-status" class="container mx-auto mb-6 h-16 flex items-center justify-center text-gray-400" style="display: none;">
      <!-- Content will be injected by JS -->
    </div>
    
    <!-- Loading Spinner -->
    <div id="loader" class="flex justify-center items-center py-20">
      <div class="loader"></div>
    </div>

    <!-- Image Grid -->
    <div id="gallery">
      <!-- Images will be injected by JS -->
    </div>
    
    <div id="no-results" class="text-center text-gray-500 py-20" style="display: none;">
      No models found.
    </div>
    
    <!-- Loader for infinite scroll -->
    <div id="scroll-loader" class="flex justify-center items-center py-10" style="display: none;">
      <div class="loader"></div>
    </div>
  </main>

  <!-- Image Viewer Modal -->
  <div id="image-viewer" class="fixed inset-0 z-[100] bg-black bg-opacity-90 overflow-y-auto" style="display: none;" onclick="closeImageViewer(event)">
    
    <!-- Close Button -->
    <button class="absolute top-4 right-6 text-white text-5xl font-light z-[120]" onclick="closeImageViewer()">&times;</button>
    
    <!-- Modal Content Scroller -->
    <div class="relative w-full max-w-6xl mx-auto" onclick="event.stopPropagation()">
    
      <!-- Main Viewer Area (80% viewport height) -->
      <div class="relative w-full h-[80vh] bg-black mt-8 md:mt-12">
        <!-- Image Header with Tags -->
        <div id="viewer-header" class="absolute top-0 left-0 right-0 p-4 bg-gradient-to-b from-black/70 to-transparent z-[105]">
          <div class="flex items-center gap-4 mb-2">
            <h3 class="text-lg font-semibold text-white">Tags</h3>
            <span id="viewer-nsfw-label" class="px-2 py-0.5 bg-red-600 text-white text-xs font-bold rounded-full" style="display: none;">NSFW</span>
          </div>
          <div id="viewer-tags" class="flex flex-wrap gap-2">
            <!-- Tags injected by JS -->
          </div>
        </div>
        
        <!-- Loader for modal image -->
        <div id="viewer-loader" class="absolute inset-0 flex items-center justify-center z-[101]">
          <div class="loader"></div>
        </div>
        
        <!-- Image Container for Zoom/Pan -->
        <div id="viewer-image-container" class="w-full h-full z-[100]">
          <!-- Full-size Image -->
          <img id="viewer-image" src="" alt="Full size model" class="max-w-none max-h-none" style="display: none;">
        </div>
        
        <!-- Navigation Buttons -->
        <button id="viewer-prev" class="absolute left-4 top-1/2 -translate-y-1/2 z-[105] p-2 bg-black/30 text-white text-3xl rounded-full hover:bg-black/60 transition-colors" onclick="prevImage(event)">&#10094;</button>
        <button id="viewer-next" class="absolute right-4 top-1/2 -translate-y-1/2 z-[105] p-2 bg-black/30 text-white text-3xl rounded-full hover:bg-black/60 transition-colors" onclick="nextImage(event)">&#10095;</button>
        
        <!-- Zoom Controls -->
        <div class="absolute bottom-4 right-4 z-[105] flex flex-col gap-2">
          <button class="w-10 h-10 bg-black/40 text-white text-xl rounded-full hover:bg-black/70" onclick="zoomIn(event)">+</button>
          <button class="w-10 h-10 bg-black/40 text-white text-xl rounded-full hover:bg-black/70" onclick="zoomOut(event)">-</button>
          <button class="w-10 h-10 bg-black/40 text-white text-sm rounded-full hover:bg-black/70" onclick="resetZoom(event)">1x</button>
        </div>
      </div>
    
      <!-- Related Models Section -->
      <div id="viewer-related-container" class="w-full min-h-[20vh] pt-4 pb-4 px-2 md:px-0">
        <h4 class="text-lg font-semibold text-gray-100 mb-2">Related Models</h4>
        <div id="viewer-related-grid">
          <!-- Related images injected by JS -->
          <span class="text-gray-500 text-sm col-span-full">Loading...</span>
        </div>
        <!-- Loader for related infinite scroll -->
        <div id="related-scroll-loader" class="flex justify-center items-center py-10" style="display: none;">
          <div class="loader"></div>
        </div>
      </div>
      
    </div> <!-- End Modal Content Scroller -->
    
  </div>

  <!-- Upload/Edit Popup Modal -->
  <div id="popup" class="fixed inset-0 z-[100] flex items-center justify-center bg-black bg-opacity-80 p-4" style="display: none;">
    <div class="bg-gray-900 p-6 rounded-lg shadow-xl w-full max-w-lg border border-gray-700">
      <h3 id="popupTitle" class="text-xl font-semibold text-white mb-4">Upload New Model(s)</h3>
      <form id="cardForm">
        <textarea id="modelUrl" rows="3" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500" placeholder="Enter one or more model URLs, separated by commas" required></textarea>
        
        <div class="mt-4">
          <label class="text-sm text-gray-400 mb-2 block">Tags</label>
          <div id="selectedTagsContainer" class="flex flex-wrap gap-2 p-2 bg-gray-800 border border-gray-700 rounded-lg min-h-[40px]">
            <!-- Selected tags injected by JS -->
          </div>
        </div>
        
        <div class="flex gap-2 mt-2">
          <select id="availableTags" class="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-blue-500">
            <option value="">Select tags to add</option>
          </select>
          <button type="button" onclick="addTagToSelection()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">Add</button>
        </div>

        <div class="mt-4 flex items-center">
          <input type="checkbox" id="modelNsfw" name="nsfw" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
          <label for="modelNsfw" class="ml-2 text-sm text-gray-300">Mark as NSFW</label>
        </div>
        
        <div id="errorMessage" class="text-red-400 text-sm mt-4"></div>
        
        <div class="mt-6 flex justify-end space-x-3">
          <button type="button" class="cancel-btn px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors" onclick="closePopup()">Cancel</button>
          <button type="submit" class="px-5 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">Save</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- START: Quick Edit Modal -->
  <div id="quick-edit-modal" class="fixed inset-0 z-[101] flex items-center justify-center bg-black bg-opacity-80 p-4" style="display: none;">
    <div class="bg-gray-900 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-700">
      <h3 class="text-xl font-semibold text-white mb-4">Edit Model</h3>
      <form id="quickEditForm">
        <!-- Hidden input to store the card ID being edited -->
        <input type="hidden" id="quickEditCardId">
        
        <div class="mb-4">
          <label for="quickEditModelUrl" class="text-sm text-gray-400 mb-2 block">Image URL</label>
          <input type="url" id="quickEditModelUrl" class="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500" required>
        </div>
        
        <div class="mb-4">
          <label class="text-sm text-gray-400 mb-2 block">Tags</label>
          <div id="quickEditSelectedTagsContainer" class="flex flex-wrap gap-2 p-2 bg-gray-800 border border-gray-700 rounded-lg min-h-[40px]">
            <!-- Selected tags injected by JS -->
          </div>
        </div>
        
        <div class="flex gap-2 mt-2 mb-4">
          <select id="quickEditAvailableTags" class="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-blue-500">
            <option value="">Select tags to add</option>
          </select>
          <button type="button" onclick="addTagToQuickEdit()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">Add</button>
        </div>

        <div id="quickEditErrorMessage" class="text-red-400 text-sm mb-4" style="display: none;"></div>
        
        <div class="mt-6 flex justify-end space-x-3">
          <button type="button" class="cancel-btn px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors" onclick="closeQuickEditModal()">Cancel</button>
          <button type="submit" class="px-5 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">Save</button>
        </div>
      </form>
    </div>
  </div>
  <!-- END: Quick Edit Modal -->
  
  <!-- Custom Context Menu -->
  <div id="context-menu">
    <button id="context-edit">‚úèÔ∏è Edit</button>
    <button id="context-delete">üóëÔ∏è Delete</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.42.3/dist/umd/supabase.min.js"></script>

  <script>
    let supabase;
    const SUPABASE_URL = 'https://fwzffqwjprjuwidkrckb.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ3emZmcXdqcHJqdXdpZGtyY2tiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgwMTMwNzMsImV4cCI6MjA2MzU4OTA3M30.p3b_pshzTN-G3QTKE91b5TGBZJwSRZTEOClXN5JEl6I';

    let selectedTags = [];
    let quickEditSelectedTags = []; // For the new quick edit modal
    let allTags = [];
    let currentlyEditingCardId = null;
    let msnry; // <-- ADDED: Masonry instance
    let currentSortOrder = 'last_uploaded'; // <-- ADDED: Sort order state
    let currentFilter = {
      type: 'all', // 'all', 'favorites', 'nsfw', 'tags'
      value: null
    };
    
    // Infinite Scroll state
    let currentPage = 0;
    const PAGE_SIZE = 25;
    let isLoadingMore = false;
    let noMoreResults = false;
    
    // DOM Elements
    let gallery, loader, noResults, searchStatus, scrollLoader;
    
    // Image Viewer elements
    const imageViewer = document.getElementById('image-viewer');
    const viewerImage = document.getElementById('viewer-image');
    const viewerHeader = document.getElementById('viewer-header');
    const viewerTags = document.getElementById('viewer-tags');
    const viewerLoader = document.getElementById('viewer-loader');
    
    // Viewer state variables
    const viewerImageContainer = document.getElementById('viewer-image-container');
    const viewerRelatedGrid = document.getElementById('viewer-related-grid');
    const relatedScrollLoader = document.getElementById('related-scroll-loader');
    let displayedCards = []; // Stores all cards loaded in the gallery
    let currentViewerIndex = 0;
    
    // Related items state
    let relatedCurrentPage = 0;
    let relatedIsLoadingMore = false;
    let relatedNoMoreResults = false;
    let currentRelatedCard = null; // The card we are finding related models for
    
    // Zoom/Pan state
    let viewerScale = 1;
    let viewerPosX = 0;
    let viewerPosY = 0;
    let isViewerDragging = false;
    let viewerStartDrag = { x: 0, y: 0 };
    let initialPinchDistance = null;
    
    // Swipe state
    let touchStartX = 0;
    let touchEndX = 0;
    
    // --- Initialization ---

    window.onload = async function () {
      // Initialize Supabase
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
      } catch (e) {
        console.error("Error initializing Supabase:", e);
        document.body.innerHTML = '<div class="p-8 text-red-400">Error: Could not connect to Supabase.</div>';
        return;
      }
      
      // Assign DOM elements
      gallery = document.getElementById('gallery');
      loader = document.getElementById('loader');
      noResults = document.getElementById('no-results');
      searchStatus = document.getElementById('search-status');
      scrollLoader = document.getElementById('scroll-loader');
      
      // --- ADDED: Initialize Masonry ---
      msnry = new Masonry( gallery, {
        itemSelector: '.masonry-item',
        percentPosition: true,
        transitionDuration: 0 // Disable animation for instant loading
      });
      // ---------------------------------
      
      // Setup context menu
      setupContextMenu();
      
      // Initial Load
      await loadTags();
      await loadTotalCardCount(); // <-- Load the total count on startup
      await loadCards(true); // Start with a new query
      
      // Event Listeners
      window.addEventListener('keydown', e => {
        if (e.key === "Escape") {
          closePopup();
          closeImageViewer();
          closeQuickEditModal(); // Also close the new modal
        }
        // Keyboard nav for viewer
        if (imageViewer.style.display === 'flex') {
          if (e.key === 'ArrowLeft') prevImage();
          if (e.key === 'ArrowRight') nextImage();
        }
      });
      
      // Add click listener to close tags dropdown
      window.addEventListener('click', (event) => {
        if (!document.getElementById('tags-dropdown-container').contains(event.target)) {
          closeTagsDropdown();
        }
      });
      
      // Add scroll event listener for infinite loading
      window.addEventListener('scroll', handleScroll);
      
      // START: Add change listener for sort order
      document.getElementById('sort-order').addEventListener('change', (event) => {
        currentSortOrder = event.target.value;
        loadCards(true); // Trigger a new search with the new sort order
      });
      // END: Add change listener
      
      // Add submit listener for the new quick edit form
      document.getElementById('quickEditForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        await handleQuickUpdate();
      });
    };
    
    // --- Data Loading ---

    // START: New function to load total card count
    async function loadTotalCardCount() {
      const countEl = document.getElementById('total-card-count');
      try {
        // Use a head request with 'exact' count for performance
        const { count, error } = await supabase
          .from('models')
          .select('*', { head: true, count: 'exact' });
          
        if (error) throw error;
        
        if (countEl) {
          countEl.textContent = `(${count} total)`;
        }
      } catch (error) {
        console.error("Error loading total card count:", error);
        if (countEl) {
          countEl.textContent = `(Error)`;
        }
      }
    }
    // END: New function
    
    async function loadTags() {
      const tagsDropdownMenu = document.getElementById('tags-dropdown-menu');
      try {
        const { data: tags, error } = await supabase
          .from('tags')
          .select('name')
          .order('name', { ascending: true });

        if (error && error.code === '42P01') {
          console.error("The 'tags' table does not exist.");
          tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-gray-500">Tag setup needed</span>';
          return;
        }
        if (error) throw error;
        
        allTags = tags.map(tag => tag.name);
        updateTagDisplays(); // This is for the main upload popup
        
        // Populate header dropdown
        tagsDropdownMenu.innerHTML = ''; // Clear 'Loading...'
        if (allTags.length > 0) {
          allTags.forEach(tag => {
            const tagLink = document.createElement('a');
            tagLink.href = "#";
            tagLink.className = "block px-4 py-2 text-sm text-gray-300 hover:bg-blue-600 hover:text-white";
            tagLink.textContent = tag;
            tagLink.onclick = (e) => {
              e.preventDefault();
              searchByTag(tag);
              closeTagsDropdown();
              document.getElementById('tags-dropdown-btn').classList.add('text-white');
              document.getElementById('tags-dropdown-btn').classList.remove('text-gray-400');
            };
            tagsDropdownMenu.appendChild(tagLink);
          });
        } else {
          tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-gray-500">No tags found</span>';
        }
        
      } catch (error) {
        console.error("Error loading tags:", error);
        tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-red-400">Error loading tags</span>';
      }
    }

    async function loadCards(isNewQuery = false) {
      if (isLoadingMore || (noMoreResults && !isNewQuery)) return;
      
      isLoadingMore = true;
      if (isNewQuery) {
        currentPage = 0;
        // Reset noMoreResults based on sort order. Shuffle mode disables pagination.
        noMoreResults = (currentSortOrder === 'shuffle');
        gallery.innerHTML = ''; // Clear gallery for new search
        displayedCards = []; // Clear displayed cards array
        noResults.style.display = 'none';
        searchStatus.style.display = 'none';
        loader.style.display = 'flex';
        // Only show scroll loader if we are NOT in shuffle mode
        scrollLoader.style.display = (currentSortOrder === 'shuffle') ? 'none' : 'flex';
      } else {
        // This block is for infinite scroll, which shuffle mode doesn't use
        scrollLoader.style.display = 'flex';
      }

      try {
        let query = supabase.from('models').select('*');

        // Apply filters
        switch (currentFilter.type) {
          case 'favorites':
            query = query.eq('favorited', true);
            searchStatus.innerHTML = '<h2 class="text-xl">Favorites</h2>';
            searchStatus.style.display = 'flex';
            updateNavActiveState('favorites');
            break;
          case 'nsfw':
            query = query.eq('nsfw', true);
            searchStatus.innerHTML = '<h2 class="text-xl text-red-400">NSFW Models</h2>';
            searchStatus.style.display = 'flex';
            updateNavActiveState('nsfw');
            break;
          case 'tags':
            const t = currentFilter.value.trim().replace(/"/g, '""');
            const orExpr = `tags.eq."${t}",tags.ilike."${t},%",tags.ilike."%,${t}",tags.ilike."%,${t},%"`;
            query = query.or(orExpr);
            searchStatus.innerHTML = `<h2 class="text-xl">Tag: <span class="px-3 py-1 bg-gray-700 text-white text-lg rounded-full">${currentFilter.value}</span></h2>`;
            searchStatus.style.display = 'flex';
            updateNavActiveState('tags');
            break;
          default: // 'all'
            query = query.eq('nsfw', false);
            updateNavActiveState('all');
            break;
        }

        // Add pagination & ordering
        if (currentSortOrder === 'shuffle') {
          // For shuffle, we fetch one large page (e.g., 100) and disable pagination
          // We also don't apply a database order. This only runs on a new query.
          if (isNewQuery) {
            query = query.limit(100); // Fetch a single large batch
          } else {
            // This shouldn't be called, but as a fallback, ensure no cards are loaded
            cards = [];
            noMoreResults = true;
          }
        } else {
          // Standard pagination and ordering
          const from = currentPage * PAGE_SIZE;
          const to = from + PAGE_SIZE - 1;
          query = query.range(from, to);
          
          if (currentSortOrder === 'first_uploaded') {
            query = query.order('created_at', { ascending: true });
          } else { // default is 'last_uploaded'
            query = query.order('created_at', { ascending: false });
          }
        }

        let { data: cards, error } = await query;
        if (error) throw error;
        
        // START: Shuffle cards client-side if that option is selected
        if (currentSortOrder === 'shuffle' && cards) {
          shuffleArray(cards);
        }
        // END: Shuffle
        
        // Client-side filter for exact tag match (Supabase 'or' is broad)
        if (currentFilter.type === 'tags') {
           const needle = currentFilter.value.toLowerCase();
           cards = (cards || []).filter(c =>
             (c.tags || '')
               .split(',')
               .map(s => s.trim().toLowerCase())
               .includes(needle)
           );
        }
        
        loader.style.display = 'none';
        scrollLoader.style.display = 'none';
        
        if (cards && cards.length > 0) {
          noResults.style.display = 'none';
          
          // START: Fix for newElements error
          const newElements = []; // Define the array
          
          // Create elements, add them to DOM and newElements array
          cards.forEach(card => {
            const index = displayedCards.length; // Get index before adding
            displayedCards.push(card); // Store card
            const cardElem = createCardElement(card, index); // Create the element
            gallery.appendChild(cardElem); // Add it to the DOM
            newElements.push(cardElem); // Add to array for imagesLoaded
          });
          // END: Fix for newElements error
          
          // --- New Masonry/imagesLoaded logic ---
          // Wait for images in the *new* elements to load
          imagesLoaded(newElements, function() {
            if (isNewQuery) {
              // For a new search, just reload all items
              msnry.reloadItems();
            } else {
              // For infinite scroll, append the new items
              msnry.addItems(newElements);
            }
            // Trigger Masonry layout
            msnry.layout();
          });
          // --- End new logic ---
          
          // Only increment page if we are NOT in shuffle mode
          if (currentSortOrder !== 'shuffle') {
            currentPage++; // Increment page for next fetch
          }
        } else {
          noMoreResults = true;
          if (isNewQuery) {
            noResults.style.display = 'block';
          }
        }
      } catch (error) {
        console.error("Error loading cards:", error);
        loader.style.display = 'none';
        scrollLoader.style.display = 'none';
        noResults.innerHTML = 'Error loading models. Check console for details.';
        noResults.style.display = 'block';
      }
      
      isLoadingMore = false;
    }
    
    // --- This function creates the card element ---
    function createCardElement(card, index) { // Added index
      const cardElem = document.createElement('div');
      // Added `group` class for hover effect on new edit button
      cardElem.className = 'masonry-item bg-gray-900 rounded-lg overflow-hidden relative group cursor-pointer';
      // Add an ID to the element for easy updating later
      cardElem.id = `card-dom-${card.id}`;
      
      const img = document.createElement('img');
      img.src = card.main_model_url.includes('ik.imagekit.io')
        ? `${card.main_model_url}?tr=w-500,q-70`
        : card.main_model_url;
      img.alt = "Model";
      img.className = "w-full h-auto block";
      img.onerror = () => { img.src = 'https://placehold.co/500x500/111827/4b5563?text=Error'; };
      
      const overlay = document.createElement('div');
      overlay.className = "overlay absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center";
      
      const tagIcon = document.createElement('span');
      tagIcon.className = "text-white text-3xl";
      tagIcon.innerHTML = "&#9776;"; // Simple list icon
      
      // START: New Edit Button
      const editButton = document.createElement('button');
      editButton.className = "absolute top-2 right-2 z-10 p-1.5 bg-black/50 rounded-full text-white hover:bg-blue-600 opacity-0 group-hover:opacity-100 transition-opacity";
      editButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.536L16.732 3.732z" />
        </svg>
      `;
      editButton.onclick = (e) => {
        e.stopPropagation(); // Prevent opening the image viewer
        openQuickEditModal(card.id);
      };
      // END: New Edit Button
      
      // START: New Delete Button
      const deleteButton = document.createElement('button');
      deleteButton.className = "absolute top-10 right-2 z-10 p-1.5 bg-black/50 rounded-full text-white hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"; // Positioned below edit button
      deleteButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      `;
      deleteButton.onclick = (e) => {
        e.stopPropagation(); // Prevent opening the image viewer
        deleteCard(card.id); // This function already has a confirm()
      };
      // END: New Delete Button
      
      overlay.appendChild(tagIcon);
      cardElem.appendChild(img);
      cardElem.appendChild(overlay);
      cardElem.appendChild(editButton); // Add the edit button to the card
      cardElem.appendChild(deleteButton); // Add the delete button to the card

      // Main click action: Open Image Viewer
      cardElem.addEventListener('click', () => {
        openImageViewer(index); // Pass index
      });
      
      // Right-click for context menu
      cardElem.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContextMenu(e, card.id);
      });
      
      // gallery.appendChild(cardElem); // <-- REMOVED: Will be appended in loadCards
      return cardElem; // <-- ADDED: Return the element
    }

    // --- Infinite Scroll ---
    
    function handleScroll() {
      // Don't load if any modal is open
      if (imageViewer.style.display === 'flex' || document.getElementById('popup').style.display === 'flex' || document.getElementById('quick-edit-modal').style.display === 'flex') return;
      
      // START: Disable infinite scroll if in shuffle mode
      if (currentSortOrder === 'shuffle') return;
      // END: Disable
      
      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
      if (scrollTop + clientHeight >= scrollHeight - 300) {
        if (!isLoadingMore && !noMoreResults) {
          loadCards();
        }
      }
    }
    
    // Infinite scroll for RELATED items (listens to modal scroll)
    function handleRelatedScroll() {
      const { scrollTop, scrollHeight, clientHeight } = imageViewer;
      if (scrollTop + clientHeight >= scrollHeight - 300) {
        if (!relatedIsLoadingMore && !relatedNoMoreResults) {
          loadRelatedImages(currentRelatedCard, false); // false = not a new query
        }
      }
    }
    
    // --- Navigation & Filtering ---
    
    function updateNavActiveState(state = null) {
        document.querySelector('a[href="#"]').classList.remove('text-white', 'font-semibold');
        document.querySelector('a[href="#"]').classList.add('text-gray-400');
        
        document.querySelector('a[onclick*="showFavorites"]').classList.remove('text-white', 'font-semibold');
        document.querySelector('a[onclick*="showFavorites"]').classList.add('text-gray-400');
        
        document.getElementById('nsfwBtn').classList.remove('text-white', 'font-semibold');
        document.getElementById('nsfwBtn').classList.add('text-gray-400');
        
        // Handle Tags button
        document.getElementById('tags-dropdown-btn').classList.remove('text-white');
        document.getElementById('tags-dropdown-btn').classList.add('text-gray-400');

        if (state === 'all') {
            document.querySelector('a[href="#"]').classList.add('text-white', 'font-semibold');
        } else if (state === 'favorites') {
            document.querySelector('a[onclick*="showFavorites"]').classList.add('text-white', 'font-semibold');
        } else if (state === 'nsfw') {
            document.getElementById('nsfwBtn').classList.add('text-white', 'font-semibold');
        } else if (state === 'tags') {
            document.getElementById('tags-dropdown-btn').classList.add('text-white');
            document.getElementById('tags-dropdown-btn').classList.remove('text-gray-400');
        }
    }

    function showAllModels(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'all', value: null };
      loadCards(true);
    }

    function showFavorites(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'favorites', value: null };
      loadCards(true);
    }

    function showNsfw(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'nsfw', value: null };
      loadCards(true);
    }
    
    function searchByTag(tag) {
      closeImageViewer();
      currentFilter = { type: 'tags', value: tag };
      loadCards(true);
    }
    
    // --- Image Viewer Functions ---
    
    // Functions to control the tags dropdown
    function toggleTagsDropdown(event) {
      event.stopPropagation(); // Prevent window.click from closing it
      const menu = document.getElementById('tags-dropdown-menu');
      menu.classList.toggle('hidden');
      
      const btn = document.getElementById('tags-dropdown-btn');
      if (!menu.classList.contains('hidden')) {
        // If opening, always set to active
        btn.classList.add('text-white');
        btn.classList.remove('text-gray-400');
      } else {
        // If closing, only remove active if not in tag filter mode
        if (currentFilter.type !== 'tags') {
           btn.classList.remove('text-white');
           btn.classList.add('text-gray-400');
        }
      }
    }

    function closeTagsDropdown() {
      document.getElementById('tags-dropdown-menu').classList.add('hidden');
      // Only remove 'text-white' if not actively filtering by tag
      const btn = document.getElementById('tags-dropdown-btn');
      if (currentFilter.type !== 'tags') {
         btn.classList.remove('text-white');
         btn.classList.add('text-gray-400');
      }
    }

    function openImageViewer(index) { // Takes index
      imageViewer.style.display = 'flex';
      imageViewer.scrollTop = 0; // Scroll modal to top
      
      // Add event listeners for viewer interactions
      imageViewer.addEventListener('scroll', handleRelatedScroll); // Listen to modal scroll
      document.addEventListener('wheel', handleViewerWheel, { passive: false });
      viewerImageContainer.addEventListener('mousedown', handleViewerMouseDown);
      document.addEventListener('mousemove', handleViewerMouseMove);
      document.addEventListener('mouseup', handleViewerMouseUp);
      viewerImageContainer.addEventListener('touchstart', handleViewerTouchStart, { passive: false });
      viewerImageContainer.addEventListener('touchmove', handleViewerTouchMove, { passive: false });
      viewerImageContainer.addEventListener('touchend', handleViewerTouchEnd);
      
      currentViewerIndex = index;
      const card = displayedCards[index];
      if (card) {
        displayCardInViewer(card);
      } else {
        console.error("Could not find card at index:", index);
        closeImageViewer();
      }
    }

    function closeImageViewer(event = null) {
      if (event) {
        // Only close if the click is on the backdrop, not children
        if (event.target !== imageViewer) return;
      }
      if (imageViewer.style.display === 'flex') {
        imageViewer.style.display = 'none';
        viewerImage.src = ''; // Stop image loading
        
        // Remove event listeners
        imageViewer.removeEventListener('scroll', handleRelatedScroll);
        document.removeEventListener('wheel', handleViewerWheel);
        viewerImageContainer.removeEventListener('mousedown', handleViewerMouseDown);
        document.removeEventListener('mousemove', handleViewerMouseMove);
        document.removeEventListener('mouseup', handleViewerMouseUp);
        viewerImageContainer.removeEventListener('touchstart', handleViewerTouchStart);
        viewerImageContainer.removeEventListener('touchmove', handleViewerTouchMove);
        viewerImageContainer.removeEventListener('touchend', handleViewerTouchEnd);
        
        resetZoom(); // Reset for next time
      }
    }
    
    // Display card data in the (already open) viewer
    function displayCardInViewer(card) {
      imageViewer.scrollTop = 0; // Scroll to top when loading new image
      resetZoom(); // Reset zoom/pan for new image
      viewerLoader.style.display = 'flex';
      viewerImage.style.display = 'none';
      viewerTags.innerHTML = '';
      
      const nsfwLabel = document.getElementById('viewer-nsfw-label');

      const fullResUrl = card.main_model_url.includes('ik.imagekit.io')
        ? card.main_model_url.split('?')[0] + '?tr=q-90'
        : card.main_model_url;
      
      viewerImage.src = fullResUrl;
      viewerImage.onload = () => {
        viewerLoader.style.display = 'none';
        viewerImage.style.display = 'block';
        applyViewerTransform(); // Apply reset zoom/pan
      };
      
      viewerImage.onerror = () => {
        viewerLoader.style.display = 'none';
        viewerImage.style.display = 'block';
        viewerImage.src = 'https://placehold.co/800x800/111827/4b5563?text=Error+Loading+Image';
        applyViewerTransform();
      };

      if (card.nsfw) nsfwLabel.style.display = 'inline-block';
      else nsfwLabel.style.display = 'none';

      const tags = card.tags ? card.tags.split(',').map(t => t.trim()).filter(t => t) : [];
      if (tags.length > 0) {
        tags.forEach(tag => {
          const tagElem = document.createElement('button');
          tagElem.className = "px-3 py-1 bg-gray-700 text-white text-sm rounded-full hover:bg-blue-600 transition-colors";
          tagElem.textContent = tag;
          tagElem.onclick = () => searchByTag(tag);
          viewerTags.appendChild(tagElem);
        });
      } else {
        viewerTags.innerHTML = `<span class="text-gray-400 text-sm">No tags for this model.</span>`;
      }
      
      // Load related images
      loadRelatedImages(card, true); // true = new query
    }
    
    // Load related images into the bottom strip
    async function loadRelatedImages(card, isNewQuery = true) {
      if (!card) return;
      
      // Prevent loading if already loading
      if (relatedIsLoadingMore) return;
      
      // Store the card we're basing this search on
      currentRelatedCard = card; 
      
      if (isNewQuery) {
        relatedCurrentPage = 0;
        relatedNoMoreResults = false;
        viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">Loading...</span>';
      } else {
        relatedScrollLoader.style.display = 'flex';
      }
      
      relatedIsLoadingMore = true;

      const tags = card.tags ? card.tags.split(',').map(t => t.trim()).filter(t => t) : [];
      if (tags.length === 0) {
        viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">No tags to find related models.</span>';
        relatedIsLoadingMore = false;
        relatedNoMoreResults = true;
        relatedScrollLoader.style.display = 'none';
        return;
      }
      
      try {
        const tagConditions = tags.map(tag => {
          const t = tag.trim().replace(/"/g, '""');
          return `tags.ilike.%${t}%`;
        }).join(',');
        
        const { data: relatedCards, error } = await supabase
          .from('models')
          .select('*')
          .or(tagConditions)
          .neq('id', card.id) // Exclude self
          .eq('nsfw', false) // Keep related SFW
          .limit(PAGE_SIZE) // Use same page size
          .range(relatedCurrentPage * PAGE_SIZE, (relatedCurrentPage + 1) * PAGE_SIZE - 1); // Pagination
          
        if (error) throw error;
        
        relatedScrollLoader.style.display = 'none';
        
        if (isNewQuery) {
          viewerRelatedGrid.innerHTML = ''; // Clear loading
        }
        
        if (relatedCards.length === 0) {
          if (isNewQuery) {
            viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">No related models found.</span>';
          }
          relatedNoMoreResults = true;
        } else {
          relatedCards.forEach(addRelatedCardToGrid);
          relatedCurrentPage++;
        }
        
      } catch (error) {
        console.error("Error loading related images:", error);
        relatedScrollLoader.style.display = 'none';
        if (isNewQuery) {
          viewerRelatedGrid.innerHTML = '<span class="text-red-400 text-sm col-span-full">Error loading related models.</span>';
        }
      }
      
      relatedIsLoadingMore = false;
    }
    
    // Function to create and add a related card to the new grid
    function addRelatedCardToGrid(relatedCard) {
      const cardElem = document.createElement('div');
      cardElem.className = 'related-masonry-item bg-gray-900 rounded-lg overflow-hidden relative group cursor-pointer';
      
      const img = document.createElement('img');
      img.src = relatedCard.main_model_url.includes('ik.imagekit.io')
        ? `${relatedCard.main_model_url}?tr=w-500,q-70` // Larger preview
        : relatedCard.main_model_url;
      img.alt = "Related Model";
      img.className = "w-full h-auto block";
      img.onerror = () => { img.src = 'https://placehold.co/500x500/111827/4b5563?text=Error'; };
      
      cardElem.appendChild(img);
      
      cardElem.onclick = () => {
        // Find the index of this related card in the main `displayedCards` array
        const relatedIndex = displayedCards.findIndex(card => card.id === relatedCard.id);
        if (relatedIndex !== -1) {
          // If it's already in our main gallery list, just jump to it
          currentViewerIndex = relatedIndex;
          displayCardInViewer(relatedCard);
        } else {
          // If it's not in the main list, just display its data
          // (Next/Prev will still be tied to the main gallery)
          displayCardInViewer(relatedCard);
        }
      };
      
      viewerRelatedGrid.appendChild(cardElem);
    }
    
    // --- Viewer Navigation ---
    
    function prevImage(event = null) {
      if(event) event.stopPropagation();
      currentViewerIndex = (currentViewerIndex - 1 + displayedCards.length) % displayedCards.length;
      displayCardInViewer(displayedCards[currentViewerIndex]);
    }
    
    function nextImage(event = null) {
      if(event) event.stopPropagation();
      currentViewerIndex = (currentViewerIndex + 1) % displayedCards.length;
      displayCardInViewer(displayedCards[currentViewerIndex]);
    }

    // --- Viewer Zoom/Pan ---
    
    function zoomIn(event = null) {
      if(event) event.stopPropagation();
      viewerScale = Math.min(viewerScale * 1.5, 10);
      applyViewerTransform();
    }
    
    function zoomOut(event = null) {
      if(event) event.stopPropagation();
      viewerScale = Math.max(viewerScale / 1.5, 0.5);
      applyViewerTransform();
    }
    
    function resetZoom(event = null) {
      if(event) event.stopPropagation();
      viewerScale = 1;
      viewerPosX = 0;
      viewerPosY = 0;
      applyViewerTransform();
    }
    
    function applyViewerTransform() {
      // Fit to container logic
      const containerWidth = viewerImageContainer.clientWidth;
      const containerHeight = viewerImageContainer.clientHeight;
      const imgWidth = viewerImage.naturalWidth;
      const imgHeight = viewerImage.naturalHeight;

      if (!imgWidth || !imgHeight) {
         // Image not loaded yet, just center
         viewerImage.style.transform = `translate(-50%, -50%) translate(${viewerPosX}px, ${viewerPosY}px) scale(${viewerScale})`;
         return;
      }

      let baseScale = 1;
      if (viewerScale === 1) {
        // Fit logic (like 'contain')
        baseScale = Math.min(containerWidth / imgWidth, containerHeight / imgHeight);
        viewerPosX = 0; // Reset position when fitting
        viewerPosY = 0;
      } else {
        // Use the 'fit' scale as the base for zooming
        baseScale = Math.min(containerWidth / imgWidth, containerHeight / imgHeight);
      }
      
      const effectiveScale = baseScale * viewerScale;
      
      // Apply transform from 50, 50 anchor
      viewerImage.style.transform = `translate(-50%, -50%) translate(${viewerPosX}px, ${viewerPosY}px) scale(${effectiveScale})`;
    }
    
    function handleViewerWheel(e) {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = -e.deltaY;
        if (delta > 0) zoomIn();
        else zoomOut();
      }
    }
    
    // --- Mouse Pan Handlers ---
    function handleViewerMouseDown(e) {
      e.preventDefault();
      isViewerDragging = true;
      viewerStartDrag = { x: e.clientX - viewerPosX, y: e.clientY - viewerPosY };
      viewerImageContainer.classList.add('grabbing');
    }
    
    function handleViewerMouseMove(e) {
      if (isViewerDragging) {
        e.preventDefault();
        viewerPosX = e.clientX - viewerStartDrag.x;
        viewerPosY = e.clientY - viewerStartDrag.y;
        applyViewerTransform();
      }
    }

    function handleViewerMouseUp() {
      isViewerDragging = false;
      viewerImageContainer.classList.remove('grabbing');
    }
    
    // --- Touch Handlers (Pinch/Pan/Swipe) ---
    function handleViewerTouchStart(e) {
      if (e.touches.length === 2) {
        // Pinch start
        e.preventDefault();
        initialPinchDistance = getPinchDistance(e.touches);
      } else if (e.touches.length === 1) {
        // Pan or Swipe start
        isViewerDragging = true;
        viewerStartDrag = { x: e.touches[0].clientX - viewerPosX, y: e.touches[0].clientY - viewerPosY };
        touchStartX = e.touches[0].clientX;
        touchEndX = e.touches[0].clientX; // Reset
      }
    }
    
    function handleViewerTouchMove(e) {
      if (e.touches.length === 2) {
        // Pinching
        e.preventDefault();
        if (initialPinchDistance === null) return;
        
        const newDistance = getPinchDistance(e.touches);
        const scaleFactor = newDistance / initialPinchDistance;
        initialPinchDistance = newDistance; // Update for next move
        
        const newScale = viewerScale * scaleFactor;
        
        // Clamp scale
        viewerScale = Math.min(Math.max(newScale, 0.5), 10);
        applyViewerTransform();
        
      } else if (e.touches.length === 1 && isViewerDragging) {
        // Panning
        if (viewerScale > 1) { // Only pan if zoomed
          e.preventDefault();
          viewerPosX = e.touches[0].clientX - viewerStartDrag.x;
          viewerPosY = e.touches[0].clientY - viewerStartDrag.y;
          applyViewerTransform();
        }
        // Track for swipe
        touchEndX = e.touches[0].clientX;
      }
    }
    
    function handleViewerTouchEnd(e) {
      if (e.touches.length === 0) {
        if (isViewerDragging) {
          // Check for swipe
          const swipeDistance = touchEndX - touchStartX;
          if (viewerScale === 1 && Math.abs(swipeDistance) > 50) { // Only swipe if not zoomed
            if (swipeDistance > 50) {
              prevImage(); // Swipe right
            } else {
              nextImage(); // Swipe left
            }
          }
        }
        
        // Reset all states
        isViewerDragging = false;
        initialPinchDistance = null;
        touchStartX = 0;
        touchEndX = 0;
      }
    }
    
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // --- Context Menu ---
    
    function setupContextMenu() {
      const menu = document.getElementById('context-menu');
      const editBtn = document.getElementById('context-edit');
      const deleteBtn = document.getElementById('context-delete');
      let currentCardId = null;

      window.addEventListener('click', () => {
        menu.style.display = 'none';
      }, true); // Use capture to hide on any click

      editBtn.onclick = () => {
        if (currentCardId) startEditCard(currentCardId);
      };
      
      deleteBtn.onclick = () => {
        if (currentCardId) deleteCard(currentCardId);
      };
      
      window.showContextMenu = (event, cardId) => {
        event.preventDefault();
        event.stopPropagation();
        currentCardId = cardId;
        menu.style.top = `${event.clientY}px`;
        menu.style.left = `${event.clientX}px`;
        menu.style.display = 'block';
      };
    }
    
    // --- Popup & CRUD ---

    function openPopup() {
      document.getElementById('popup').style.display = 'flex';
      updateTagDisplays(); // Re-populate tags dropdown
    }

    function closePopup() {
      document.getElementById('popup').style.display = 'none';
      resetForm();
    }
    
    function resetForm() {
      document.getElementById('cardForm').reset();
      selectedTags = [];
      currentlyEditingCardId = null;
      document.getElementById('popupTitle').textContent = 'Add New Model(s)';
      document.getElementById('modelUrl').placeholder = "Enter one or more model URLs, separated by commas";
      document.getElementById('modelNsfw').checked = false;
      updateSelectedTagsDisplay();
      updateTagDisplays();
      document.getElementById('errorMessage').textContent = '';
    }

    async function addCard() {
      const errorMessage = document.getElementById('errorMessage');
      try {
        const modelUrlsText = document.getElementById('modelUrl').value.trim();
        if (!modelUrlsText) throw new Error("Model URL(s) are required.");

        const urls = modelUrlsText.split(',').map(url => url.trim()).filter(url => url.length > 0);
        if (urls.length === 0) throw new Error("Please provide at least one valid model URL.");
        
        const isNsfw = document.getElementById('modelNsfw').checked;
        const tagsString = selectedTags.join(', ');

        const newCards = urls.map(url => ({
          tags: tagsString,
          main_model_url: url,
          related_models: [], // These are old/unused but good to init
          related_models_with_tags: [], // "
          favorited: false,
          nsfw: isNsfw
        }));

        const { error } = await supabase.from('models').insert(newCards);
        if (error) throw error;

        closePopup();
        await loadTotalCardCount(); // <-- Refresh count after adding
        showAllModels(); // Refresh view
      } catch (error) {
        console.error("Error adding card:", error);
        errorMessage.textContent = `Failed to add model(s): ${error.message}`;
      }
    }
    
    async function startEditCard(cardId) {
      try {
        const { data: card, error } = await supabase.from('models').select('*').eq('id', cardId).single();
        if (error) throw error;

        currentlyEditingCardId = cardId;
        const modelUrlInput = document.getElementById('modelUrl');
        modelUrlInput.value = card.main_model_url;
        modelUrlInput.placeholder = "Model URL";
        
        selectedTags = card.tags ? card.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        document.getElementById('modelNsfw').checked = card.nsfw;
        
        updateSelectedTagsDisplay();
        document.getElementById('popupTitle').textContent = 'Edit Model';
        openPopup();
      } catch (error) {
        console.error("Error loading card for edit:", error);
        alert("Failed to load card for editing");
      }
    }

    async function updateCard() {
      const errorMessage = document.getElementById('errorMessage');
      try {
        const modelUrl = document.getElementById('modelUrl').value.trim();
        if (!modelUrl || modelUrl.includes(',')) {
            throw new Error("A single, valid Model URL is required when editing.");
        }
        
        const isNsfw = document.getElementById('modelNsfw').checked;
        const tagsString = selectedTags.join(', ');

        const { error } = await supabase
          .from('models')
          .update({ 
            main_model_url: modelUrl,
            tags: tagsString,
            nsfw: isNsfw
          })
          .eq('id', currentlyEditingCardId);
        
        if (error) throw error;
        
        closePopup();
        loadCards(true); // Force a full refresh
      } catch (error) {
        console.error("Error updating card:", error);
        errorMessage.textContent = error.message;
      }
    }

    async function deleteCard(cardId) {
      // We don't need a custom modal, browser confirm is fine here
      if (!confirm("Are you sure you want to delete this model?")) return;
      try {
        const { error } = await supabase.from('models').delete().eq('id', cardId);
        if (error) throw error;
        await loadTotalCardCount(); // <-- Refresh count after deleting
        loadCards(true); // Force a full refresh
      } catch (error) {
        console.error("Error deleting card:", error);
        alert("Failed to delete card");
      }
    }
    
    // Popup form submit handler
    document.getElementById('cardForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      if (currentlyEditingCardId) {
        await updateCard();
      } else {
        await addCard();
      }
    });

    // --- Tag Selection UI (Main Upload) ---

    function updateTagDisplays() {
      const availableTagsSelect = document.getElementById('availableTags');
      availableTagsSelect.innerHTML = '<option value="">Select tags to add</option>';
      allTags.forEach(tag => {
        if (!selectedTags.includes(tag)) {
          const option = document.createElement('option');
          option.value = tag;
          option.textContent = tag;
          availableTagsSelect.appendChild(option);
        }
      });
    }

    function addTagToSelection() {
      const select = document.getElementById('availableTags');
      const selectedTag = select.value;
      if (!selectedTag || selectedTags.includes(selectedTag)) return;
      
      selectedTags.push(selectedTag);
      updateSelectedTagsDisplay();
      updateTagDisplays(); // Re-populates the dropdown
      select.value = ""; // Reset dropdown
    }
    
    function updateSelectedTagsDisplay() {
      const container = document.getElementById('selectedTagsContainer');
      container.innerHTML = '';
      selectedTags.forEach(tag => {
        const tagElem = document.createElement('span');
        tagElem.className = 'px-3 py-1 bg-blue-600 text-white text-sm rounded-full flex items-center gap-2';
        tagElem.innerHTML = `
          ${tag}
          <button type="button" class="text-blue-200 hover:text-white" onclick="removeSelectedTag('${tag}')">&times;</button>
        `;
        container.appendChild(tagElem);
      });
    }

    function removeSelectedTag(tagToRemove) {
      selectedTags = selectedTags.filter(tag => tag !== tagToRemove);
      updateSelectedTagsDisplay();
      updateTagDisplays(); // Re-populates the dropdown
    }
    
    // --- START: Quick Edit Modal Functions ---
    
    async function openQuickEditModal(cardId) {
      try {
        const { data: card, error } = await supabase.from('models').select('*').eq('id', cardId).single();
        if (error) throw error;

        document.getElementById('quickEditCardId').value = card.id;
        document.getElementById('quickEditModelUrl').value = card.main_model_url;
        
        quickEditSelectedTags = card.tags ? card.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        
        updateQuickEditSelectedTagsDisplay();
        updateQuickEditAvailableTags();
        
        document.getElementById('quickEditErrorMessage').style.display = 'none';
        document.getElementById('quick-edit-modal').style.display = 'flex';
      } catch (error) {
        console.error("Error loading card for quick edit:", error);
        alert("Failed to load card for editing");
      }
    }
    
    function closeQuickEditModal() {
      document.getElementById('quick-edit-modal').style.display = 'none';
      document.getElementById('quickEditForm').reset();
      quickEditSelectedTags = [];
      document.getElementById('quickEditErrorMessage').style.display = 'none';
    }
    
    async function handleQuickUpdate() {
      const cardId = document.getElementById('quickEditCardId').value;
      const newUrl = document.getElementById('quickEditModelUrl').value.trim();
      const newTags = quickEditSelectedTags.join(', ');
      const errorMsg = document.getElementById('quickEditErrorMessage');

      if (!newUrl) {
        errorMsg.textContent = "Image URL is required.";
        errorMsg.style.display = 'block';
        return;
      }
      
      try {
        // Update the database and get the updated row back
        const { data: updatedCard, error } = await supabase
          .from('models')
          .update({ 
            main_model_url: newUrl,
            tags: newTags
          })
          .eq('id', cardId)
          .select()
          .single(); // .select().single() returns the updated row
        
        if (error) throw error;

        // --- Start Local Data & UI Update ---
        
        // 1. Update the main `displayedCards` array
        const index = displayedCards.findIndex(c => c.id == cardId);
        if (index !== -1) {
          displayedCards[index] = updatedCard;
        }
        
        // 2. Update the card in the gallery grid
        const cardElem = document.getElementById(`card-dom-${cardId}`);
        if (cardElem) {
          const img = cardElem.querySelector('img');
          if (img) {
            img.src = updatedCard.main_model_url.includes('ik.imagekit.io')
              ? `${updatedCard.main_model_url}?tr=w-500,q-70`
              : updatedCard.main_model_url;
          }
        }
        
        // 3. Update the viewer IF it's open and showing this card
        if (imageViewer.style.display === 'flex' && currentViewerIndex === index) {
          displayCardInViewer(updatedCard);
        }
        
        // --- End Local Data & UI Update ---

        closeQuickEditModal();
        
      } catch (error) {
        console.error("Error updating card:", error);
        errorMsg.textContent = `Failed to update: ${error.message}`;
        errorMsg.style.display = 'block';
      }
    }
    
    // --- Tag Helpers for Quick Edit Modal ---
    
    function updateQuickEditAvailableTags() {
      const availableTagsSelect = document.getElementById('quickEditAvailableTags');
      availableTagsSelect.innerHTML = '<option value="">Select tags to add</option>';
      allTags.forEach(tag => {
        if (!quickEditSelectedTags.includes(tag)) {
          const option = document.createElement('option');
          option.value = tag;
          option.textContent = tag;
          availableTagsSelect.appendChild(option);
        }
      });
    }

    function addTagToQuickEdit() {
      const select = document.getElementById('quickEditAvailableTags');
      const selectedTag = select.value;
      if (!selectedTag || quickEditSelectedTags.includes(selectedTag)) return;
      
      quickEditSelectedTags.push(selectedTag);
      updateQuickEditSelectedTagsDisplay();
      updateQuickEditAvailableTags();
      select.value = "";
    }
    
    function updateQuickEditSelectedTagsDisplay() {
      const container = document.getElementById('quickEditSelectedTagsContainer');
      container.innerHTML = '';
      quickEditSelectedTags.forEach(tag => {
        const tagElem = document.createElement('span');
        tagElem.className = 'px-3 py-1 bg-blue-600 text-white text-sm rounded-full flex items-center gap-2';
        tagElem.innerHTML = `
          ${tag}
          <button type="button" class="text-blue-200 hover:text-white" onclick="removeQuickEditSelectedTag('${tag}')">&times;</button>
        `;
        container.appendChild(tagElem);
      });
    }

    function removeQuickEditSelectedTag(tagToRemove) {
      quickEditSelectedTags = quickEditSelectedTags.filter(tag => tag !== tagToRemove);
      updateQuickEditSelectedTagsDisplay();
      updateQuickEditAvailableTags();
    }
    
    // --- END: Quick Edit Modal Functions ---
    
    // --- START: Shuffle Utility Function ---
    /**
     * Shuffles an array in place using the Fisher-YATES algorithm.
     * @param {Array} array The array to shuffle.
     */
    function shuffleArray(array) {
      let currentIndex = array.length,  randomIndex;
      // While there remain elements to shuffle.
      while (currentIndex != 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
          array[randomIndex], array[currentIndex]];
      }
      return array;
    }
    // --- END: Shuffle Utility Function ---

  </script>
</body>
</html>
