<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="robots" content="noindex, nofollow">
  <link rel="icon" href="https://ik.imagekit.io/xfifcyvcg/P_icon.ico?updatedAt=1748049193174" type="image/x-icon">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Model Gallery | Visual Search</title>
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- START: Added Masonry & imagesLoaded -->
  <script src="https://unpkg.com/imagesloaded@5/imagesloaded.pkgd.min.js"></script>
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
  <!-- END: Added Masonry & imagesLoaded -->
  <style>
    /* Custom scrollbar for a cleaner look */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }
    ::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #555;
    }

    /* Simple loading spinner */
    .loader {
      border: 4px solid #333;
      border-top: 4px solid #999;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Custom context menu */
    #context-menu {
      display: none;
      position: fixed;
      z-index: 1000;
      background-color: #2a2a2a;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #context-menu button {
      display: block;
      width: 100%;
      padding: 8px 16px;
      background: none;
      border: none;
      color: #e0e0e0;
      text-align: left;
      border-radius: 4px;
      cursor: pointer;
    }
    #context-menu button:hover {
      background-color: #3b82f6; /* Tailwind blue-500 */
      color: white;
    }
    
    /* Style for the new sort dropdown */
    #sort-order {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='currentColor' aria-hidden='true'%3e%3cpath fill-rule='evenodd' d='M10 3a.75.75 0 01.55.24l3.25 3.5a.75.75 0 11-1.1 1.02L10 4.852 7.3 7.76a.75.75 0 01-1.1-1.02l3.25-3.5A.75.75 0 0110 3zm-3.7 9.24a.75.75 0 011.1 1.02L10 15.148l2.7-2.888a.75.75 0 111.1 1.02l-3.25 3.5a.75.75 0 01-1.1 0l-3.25-3.5a.75.75 0 010-1.02z' clip-rule='evenodd'/%3e%3c/svg%3e");
      background-size: 1.25rem;
      background-repeat: no-repeat;
      background-position: right 0.5rem center;
      padding-right: 2.25rem; /* Make space for icon */
    }
    
    /* Masonry Layout */
    #gallery {
      /* Reverted back to column-count for masonry layout */
      /* REMOVED: column-count, column-gap. Masonry.js will handle this. */
      position: relative; /* Required for Masonry.js positioning */
    }
    /*
    @media (min-width: 768px) { 
      #gallery { column-count: 3; }
    }
    @media (min-width: 1024px) { 
      #gallery { column-count: 4; }
    }
    @media (min-width: 1280px) { 
      #gallery { column-count: 5; }
    }
    @media (min-width: 1536px) { 
      #gallery { column-count: 6; }
    }
    */
    
    .masonry-item {
      /* Re-instated properties for masonry items */
      /* REMOVED: display: inline-block; */
      /* UPDATED: Widths for Masonry.js to calculate columns using calc() for fixed margins */
      width: calc(50% - 8px); /* 2 cols. 4px margin L/R on each item = 8px total per item */
      margin-bottom: 8px; 
      margin-left: 4px;
      margin-right: 4px;
      /* REMOVED: break-inside: avoid; */
    }
    /* UPDATED: Responsive widths for Masonry.js with calc() */
    @media (min-width: 768px) { /* md */
      .masonry-item { width: calc(33.333% - 8px); } /* 3 cols */
    }
    @media (min-width: 1024px) { /* lg */
      .masonry-item { width: calc(25% - 8px); } /* 4 cols */
    }
    @media (min-width: 1280px) { /* xl */
      .masonry-item { width: calc(20% - 8px); } /* 5 cols */
    }
    @media (min-width: 1536px) { /* 2xl */
      .masonry-item { width: calc(16.666% - 8px); } /* 6 cols */
    }
    

    /* Card item hover effect (renamed from .grid-item) */
    .masonry-item .overlay {
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }
    .masonry-item:hover .overlay {
      opacity: 1;
    }
    
    /* Viewer Zoom/Pan Styles */
    #viewer-image-container {
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
      position: relative; /* For image positioning */
    }
    #viewer-image-container.grabbing {
      cursor: grabbing;
    }
    #viewer-image {
      transform-origin: center center;
      transition: transform 0.1s ease-out;
      position: absolute; /* Allows for centering */
      top: 50%;
      left: 50%;
      will-change: transform; /* Hint for browser performance */
    }
    
    /* Masonry Layout for Related Grid */
    #viewer-related-grid {
      column-count: 2;
      column-gap: 4px; /* Tailwind gap-1 */
    }
    @media (min-width: 768px) { /* md */
      #viewer-related-grid { 
        column-count: 3; 
        column-gap: 8px; /* Tailwind gap-2 */
      }
    }
    
    .related-masonry-item {
      display: inline-block;
      width: 100%;
      margin-bottom: 8px; /* Match main gallery gap */
      break-inside: avoid;
    }
  </style>
</head>
<body class="bg-black text-gray-300 font-sans antialiased">

  <!-- Header Navigation -->
  <header class="fixed top-0 left-0 right-0 z-50 bg-black bg-opacity-80 backdrop-blur-sm">
    <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
      
      <!-- Left Side: Hamburger (Mobile) + Nav Links (Desktop) -->
      <div class="flex items-center space-x-6">
        <!-- Hamburger Button (Mobile) -->
        <button id="menu-btn" class="lg:hidden text-white p-1 -ml-1" onclick="toggleMobileMenu()">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
        </button>
        
        <!-- Desktop Nav Links (Hidden on Mobile) -->
        <div class="hidden lg:flex items-center space-x-6">
          <a href="#" onclick="showAllModels(event)" class="text-lg font-semibold text-white hover:text-gray-300">Home</a>
          <!-- START: Added Albums Link -->
          <a href="#" id="albums-link" onclick="showAllAlbums(event)" class="text-sm text-gray-400 hover:text-white">Albums</a>
          <!-- END: Added Albums Link -->
          
          <!-- START: New Total Count Element -->
          <span class="text-sm text-gray-500" id="total-card-count">(...)</span>
          <!-- END: New Total Count Element -->
          
          <a href="#" onclick="showFavorites(event)" class="text-sm text-gray-400 hover:text-white">Favorites</a>
          <a href="#" onclick="showNsfw(event)" id="nsfwBtn" class="text-sm text-gray-400 hover:text-white">NSFW</a>
          
          <!-- Tags Dropdown -->
          <!-- MOVED this block to the right side -->
          <!-- END Tags Dropdown -->
          
          <!-- START: Sort Order Dropdown -->
          <div class="relative">
            <select id="sort-order" class="text-sm text-gray-400 hover:text-white focus:outline-none bg-transparent border-0 focus:ring-0">
              <option value="last_uploaded" class="bg-gray-800">Last uploaded</option>
              <option value="first_uploaded" class="bg-gray-800">First uploaded</option>
              <option value="shuffle" class="bg-gray-800">Shuffle</option>
            </select>
          </div>
          <!-- END: Sort Order Dropdown -->
        </div>
      </div>
      
      <!-- Right Side: Action Buttons -->
      <div class="flex items-center space-x-3">
        <!-- START: Tags Dropdown (Moved Here) -->
        <div class="relative" id="tags-dropdown-container">
          <button onclick="toggleTagsDropdown(event)" id="tags-dropdown-btn" class="text-sm text-gray-400 hover:text-white focus:outline-none">
            Tags
          </button>
          <!-- Changed left-0 to right-0 to align the dropdown correctly on the right side -->
          <div id="tags-dropdown-menu" class="hidden absolute top-full right-0 mt-2 w-56 bg-gray-800 border border-gray-700 rounded-lg shadow-lg z-10 py-2 max-h-64 overflow-y-auto">
            <!-- JS will populate this -->
            <span class="block px-4 py-2 text-sm text-gray-500">Loading...</span>
          </div>
        </div>
        <!-- END: Tags Dropdown (Moved Here) -->

        <button onclick="openManageTagsPopup()" class="hidden lg:block px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors">
          Add Tags
        </button>
        <button onclick="openPopup()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">
          Upload
        </button>
      </div>
    </nav>

    <!-- Mobile Menu (Hidden by default) -->
    <div id="mobile-menu" class="hidden lg:hidden bg-gray-900 bg-opacity-95" style="background-color: #111827f8;"> <!-- A bit of custom color to match -->
      <div class="container mx-auto px-6 py-4 flex flex-col space-y-4">
        <a href="#" onclick="mobileMenuClicked('showAllModels')" class="block text-lg font-semibold text-white hover:text-gray-300">Home</a>
        <a href="#" onclick="mobileMenuClicked('showAllAlbums')" class="block text-lg text-gray-300 hover:text-white">Albums</a>
        <a href="#" onclick="mobileMenuClicked('showFavorites')" class="block text-lg text-gray-300 hover:text-white">Favorites</a>
        <a href="#" onclick="mobileMenuClicked('showNsfw')" class="block text-lg text-gray-300 hover:text-white">NSFW</a>
        
        <!-- Mobile Tags -->
        <!-- REMOVED this section -->
        <!-- END Mobile Tags -->

        <!-- Mobile Sort -->
        <div class="relative mt-2">
          <label for="mobile-sort-order" class="text-lg text-gray-300 mr-2">Sort by:</label>
          <select id="mobile-sort-order" class="text-lg text-gray-300 hover:text-white focus:outline-none bg-transparent border-0 focus:ring-0 p-1">
            <option value="last_uploaded" class="bg-gray-800">Last uploaded</option>
            <option value="first_uploaded" class="bg-gray-800">First uploaded</option>
            <option value="shuffle" class="bg-gray-800">Shuffle</option>
          </select>
        </div>
        
        <!-- Mobile Add Tags Button -->
        <button onclick="mobileMenuClicked('openManageTagsPopup')" class="w-full px-4 py-3 bg-gray-700 hover:bg-gray-600 text-white text-md font-medium rounded-lg transition-colors">
          Add Tags
        </button>
      </div>
    </div>
  </header>

  <!-- Main Content Area -->
  <main class="pt-24 pb-12 px-4 md:px-6">
    
    <!-- Search/Filter Status -->
    <div id="search-status" class="container mx-auto mb-6 h-16 flex items-center justify-center text-gray-400" style="display: none;">
      <!-- Content will be injected by JS -->
    </div>
    
    <!-- Loading Spinner -->
    <div id="loader" class="flex justify-center items-center py-20">
      <div class="loader"></div>
    </div>

    <!-- Image Grid -->
    <div id="gallery">
      <!-- Images will be injected by JS -->
    </div>
    
    <div id="no-results" class="text-center text-gray-500 py-20" style="display: none;">
      No models found.
    </div>
    
    <!-- Loader for infinite scroll -->
    <div id="scroll-loader" class="flex justify-center items-center py-10" style="display: none;">
      <div class="loader"></div>
    </div>
  </main>

  <!-- Image Viewer Modal -->
  <div id="image-viewer" class="fixed inset-0 z-[100] bg-black bg-opacity-90 overflow-y-auto" style="display: none;" onclick="closeImageViewer(event)">
    
    <!-- Close Button -->
    <button class="absolute top-4 right-6 text-white text-5xl font-light z-[120]" onclick="closeImageViewer()">&times;</button>
    
    <!-- Modal Content Scroller -->
    <div class="relative w-full max-w-6xl mx-auto" onclick="event.stopPropagation()">
    
      <!-- Main Viewer Area (80% viewport height) -->
      <div class="relative w-full h-[80vh] bg-black mt-8 md:mt-12">
        <!-- Image Header with Tags -->
        <div id="viewer-header" class="absolute top-0 left-0 right-0 p-4 bg-gradient-to-b from-black/70 to-transparent z-[105]">
          <div class="flex items-center gap-4 mb-2">
            <h3 class="text-lg font-semibold text-white">Tags</h3>
            <span id="viewer-nsfw-label" class="px-2 py-0.5 bg-red-600 text-white text-xs font-bold rounded-full" style="display: none;">NSFW</span>
          </div>
          <div id="viewer-tags" class="flex flex-wrap gap-2">
            <!-- Tags injected by JS -->
          </div>
        </div>
        
        <!-- Loader for modal image -->
        <div id="viewer-loader" class="absolute inset-0 flex items-center justify-center z-[101]">
          <div class="loader"></div>
        </div>
        
        <!-- Image Container for Zoom/Pan -->
        <div id="viewer-image-container" class="w-full h-full z-[100]">
          <!-- Full-size Image -->
          <img id="viewer-image" src="" alt="Full size model" class="max-w-none max-h-none" style="display: none;">
        </div>
        
        <!-- Navigation Buttons -->
        <button id="viewer-prev" class="absolute left-4 top-1/2 -translate-y-1/2 z-[105] p-2 bg-black/30 text-white text-3xl rounded-full hover:bg-black/60 transition-colors" onclick="prevImage(event)">&#10094;</button>
        <button id="viewer-next" class="absolute right-4 top-1/2 -translate-y-1/2 z-[105] p-2 bg-black/30 text-white text-3xl rounded-full hover:bg-black/60 transition-colors" onclick="nextImage(event)">&#10095;</button>
        
        <!-- Zoom Controls -->
        <div class="absolute bottom-4 right-4 z-[105] flex flex-col gap-2">
          <button class="w-10 h-10 bg-black/40 text-white text-xl rounded-full hover:bg-black/70" onclick="zoomIn(event)">+</button>
          <button class="w-10 h-10 bg-black/40 text-white text-xl rounded-full hover:bg-black/70" onclick="zoomOut(event)">-</button>
          <button class="w-10 h-10 bg-black/40 text-white text-sm rounded-full hover:bg-black/70" onclick="resetZoom(event)">1x</button>
        </div>
      </div>
    
      <!-- Related Models Section -->
      <div id="viewer-related-container" class="w-full min-h-[20vh] pt-4 pb-4 px-2 md:px-0">
        <!-- START: Title changed, will be set by JS -->
        <div class="flex justify-between items-center mb-2">
          <h4 class="text-lg font-semibold text-gray-100">Related Models</h4>
          <!-- START: Add to Album Button -->
          <button id="add-to-album-btn" onclick="openUploadForAlbum()" class="flex items-center gap-1 px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded-lg transition-colors" style="display: none;">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
            </svg>
            Add
          </button>
          <!-- END: Add to Album Button -->
        </div>
        <!-- END: Title changed -->
        <div id="viewer-related-grid">
          <!-- Related images injected by JS -->
          <span class="text-gray-500 text-sm col-span-full">Loading...</span>
        </div>
        <!-- Loader for related infinite scroll -->
        <div id="related-scroll-loader" class="flex justify-center items-center py-10" style="display: none;">
          <div class="loader"></div>
        </div>
      </div>
      
    </div> <!-- End Modal Content Scroller -->
    
  </div>

  <!-- Upload/Edit Popup Modal -->
  <div id="popup" class="fixed inset-0 z-[100] flex items-center justify-center bg-black bg-opacity-80 p-4" style="display: none;">
    <div class="bg-gray-900 p-6 rounded-lg shadow-xl w-full max-w-lg border border-gray-700">
      <h3 id="popupTitle" class="text-xl font-semibold text-white mb-4">Upload New Model(s)</h3>
      <form id="cardForm">
        
        <!-- START: Added Album Name Field -->
        <input type="text" id="modelAlbumName" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 mb-4" placeholder="Model/Album Name (Optional)">
        <!-- END: Added Album Name Field -->
        
        <!-- START: Changed placeholder -->
        <textarea id="modelUrl" rows="3" class="w-full p-3 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500" placeholder="Enter one or more image URLs, separated by commas" required></textarea>
        <!-- END: Changed placeholder -->
        
        <div class="mt-4">
          <label class="text-sm text-gray-400 mb-2 block">Tags</label>
          <div id="selectedTagsContainer" class="flex flex-wrap gap-2 p-2 bg-gray-800 border border-gray-700 rounded-lg min-h-[40px]">
            <!-- Selected tags injected by JS -->
          </div>
        </div>
        
        <div class="flex gap-2 mt-2">
          <select id="availableTags" class="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-blue-500">
            <option value="">Select tags to add</option>
          </select>
          <button type="button" onclick="addTagToSelection()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">Add</button>
        </div>

        <div class="mt-4 flex items-center">
          <input type="checkbox" id="modelNsfw" name="nsfw" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
          <label for="modelNsfw" class="ml-2 text-sm text-gray-300">Mark as NSFW</label>
        </div>
        
        <div id="errorMessage" class="text-red-400 text-sm mt-4"></div>
        
        <div class="mt-6 flex justify-end space-x-3">
          <button type="button" class="cancel-btn px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors" onclick="closePopup()">Cancel</button>
          <button type="submit" class="px-5 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">Save</button>
        </div>
      </form>
    </div>
  </div>
  
  <!-- START: Quick Edit Modal -->
  <div id="quick-edit-modal" class="fixed inset-0 z-[101] flex items-center justify-center bg-black bg-opacity-80 p-4" style="display: none;">
    <div class="bg-gray-900 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-700">
      <h3 class="text-xl font-semibold text-white mb-4">Edit Model</h3>
      <form id="quickEditForm">
        <!-- Hidden input to store the card ID being edited -->
        <input type="hidden" id="quickEditCardId">
        
        <div class="mb-4">
          <label for="quickEditModelUrl" class="text-sm text-gray-400 mb-2 block">Image URL</label>
          <input type="url" id="quickEditModelUrl" class="w-full p-2 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500" required>
        </div>
        
        <div class="mb-4">
          <label class="text-sm text-gray-400 mb-2 block">Tags</label>
          <div id="quickEditSelectedTagsContainer" class="flex flex-wrap gap-2 p-2 bg-gray-800 border border-gray-700 rounded-lg min-h-[40px]">
            <!-- Selected tags injected by JS -->
          </div>
        </div>
        
        <div class="flex gap-2 mt-2 mb-4">
          <select id="quickEditAvailableTags" class="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg text-white focus:outline-none focus:border-blue-500">
            <option value="">Select tags to add</option>
          </select>
          <button type="button" onclick="addTagToQuickEdit()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium rounded-lg transition-colors">Add</button>
        </div>
        
        <!-- START: Added NSFW Checkbox -->
        <div class="flex items-center mb-4">
          <input type="checkbox" id="quickEditModelNsfw" name="nsfw" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600">
          <label for="quickEditModelNsfw" class="ml-2 text-sm text-gray-300">Mark as NSFW</label>
        </div>
        <!-- END: Added NSFW Checkbox -->

        <div id="quickEditErrorMessage" class="text-red-400 text-sm mb-4" style="display: none;"></div>
        
        <div class="mt-6 flex justify-end space-x-3">
          <button type="button" class="cancel-btn px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors" onclick="closeQuickEditModal()">Cancel</button>
          <button type="submit" class="px-5 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">Save</button>
        </div>
      </form>
    </div>
  </div>
  <!-- END: Quick Edit Modal -->
  
  <!-- START: Add Tags Modal -->
  <div id="manage-tags-popup" class="fixed inset-0 z-[101] flex items-center justify-center bg-black bg-opacity-80 p-4" style="display: none;">
    <div class="bg-gray-900 p-6 rounded-lg shadow-xl w-full max-w-md border border-gray-700">
      <h3 class="text-xl font-semibold text-white mb-4">Manage Tags</h3>
      
      <!-- Form to add new tag -->
      <form id="addTagForm" class="flex flex-col gap-2 mb-4">
        <div class="flex gap-2">
          <input type="text" id="newTagName" class="flex-grow p-2 bg-gray-800 border border-gray-700 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500" placeholder="Enter new tag name" required>
          <button type="submit" class="px-5 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-medium rounded-lg transition-colors">Add</button>
        </div>
        <div id="manageTagsErrorMessage" class="text-red-400 text-sm" style="display: none;"></div>
      </form>

      <!-- START: Action Buttons -->
      <div class="flex items-center gap-2 mb-2">
        <button type="button" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs font-medium rounded-lg" onclick="selectAllManageTags(true)">Select All</button>
        <button type="button" class="px-3 py-1 bg-gray-700 hover:bg-gray-600 text-white text-xs font-medium rounded-lg" onclick="selectAllManageTags(false)">Deselect All</button>
        <div class="flex-grow"></div>
        <button type="button" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded-lg" onclick="handleRenameSelectedTag()">Rename Selected</button>
        <button type="button" class="px-3 py-1 bg-red-600 hover:bg-red-700 text-white text-xs font-medium rounded-lg" onclick="handleDeleteSelectedTags()">Delete Selected</button>
      </div>
      <!-- END: Action Buttons -->

      <!-- List of existing tags -->
      <h4 class="text-md font-semibold text-gray-300 mb-2">Existing Tags</h4>
      <div id="existingTagsListContainer" class="max-h-64 overflow-y-auto bg-gray-800 border border-gray-700 rounded-lg p-2">
        <!-- Tags will be loaded here -->
        <span class="text-gray-500">Loading...</span>
      </div>
      
      <div class="mt-6 flex justify-end">
        <button type="button" class="cancel-btn px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white text-sm font-medium rounded-lg transition-colors" onclick="closeManageTagsPopup()">Close</button>
      </div>
    </div>
  </div>
  <!-- END: Add Tags Modal -->
  
  <!-- Custom Context Menu -->
  <div id="context-menu">
    <button id="context-edit">‚úèÔ∏è Edit</button>
    <button id="context-delete">üóëÔ∏è Delete</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.42.3/dist/umd/supabase.min.js"></script>

  <script>
    let supabase;
    const SUPABASE_URL = 'https://fwzffqwjprjuwidkrckb.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ3emZmcXdqcHJqdXdpZGtyY2tiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDgwMTMwNzMsImV4cCI6MjA2MzU4OTA3M30.p3b_pshzTN-G3QTKE91b5TGBZJwSRZTEOClXN5JEl6I';

    let selectedTags = [];
    let quickEditSelectedTags = []; // For the new quick edit modal
    let allTags = [];
    let tagCountMap = {}; // <-- ADDED
    let currentlyEditingCardId = null;
    let msnry; // <-- ADDED: Masonry instance
    let currentSortOrder = 'last_uploaded'; // <-- ADDED: Sort order state
    let currentFilter = {
      type: 'all_singles', // 'all_singles', 'all_albums', 'favorites', 'nsfw', 'tags'
      value: null
    };
    
    // Infinite Scroll state
    let currentPage = 0;
    const PAGE_SIZE = 25;
    let isLoadingMore = false;
    let noMoreResults = false;
    
    // DOM Elements
    let gallery, loader, noResults, searchStatus, scrollLoader, mobileMenu;
    
    // Image Viewer elements
    const imageViewer = document.getElementById('image-viewer');
    const viewerImage = document.getElementById('viewer-image');
    const viewerHeader = document.getElementById('viewer-header');
    const viewerTags = document.getElementById('viewer-tags');
    const viewerLoader = document.getElementById('viewer-loader');
    
    // Viewer state variables
    const viewerImageContainer = document.getElementById('viewer-image-container');
    const viewerRelatedGrid = document.getElementById('viewer-related-grid');
    const relatedScrollLoader = document.getElementById('related-scroll-loader');
    
    // START: albumsSeenThisSession
    // This tracks which albums we've already shown a cover for
    let albumsSeenThisSession = new Set();
    // END: albumsSeenThisSession
    
    let displayedCards = []; // Stores all cards loaded *in the gallery*
    let currentViewerIndex = 0;
    
    // Related items state
    let relatedCurrentPage = 0;
    let relatedIsLoadingMore = false;
    let relatedNoMoreResults = false;
    let currentRelatedCard = null; // The card we are finding related models for
    
    // Zoom/Pan state
    let viewerScale = 1;
    let viewerPosX = 0;
    let viewerPosY = 0;
    let isViewerDragging = false;
    let viewerStartDrag = { x: 0, y: 0 };
    let initialPinchDistance = null;
    
    // Swipe state
    let touchStartX = 0;
    let touchEndX = 0;
    
    // --- Initialization ---

    window.onload = async function () {
      // Initialize Supabase
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
      } catch (e) {
        console.error("Error initializing Supabase:", e);
        document.body.innerHTML = '<div class="p-8 text-red-400">Error: Could not connect to Supabase.</div>';
        return;
      }
      
      // Assign DOM elements
      gallery = document.getElementById('gallery');
      loader = document.getElementById('loader');
      noResults = document.getElementById('no-results');
      searchStatus = document.getElementById('search-status');
      scrollLoader = document.getElementById('scroll-loader');
      mobileMenu = document.getElementById('mobile-menu'); // <-- Add this
      
      // --- ADDED: Initialize Masonry ---
      msnry = new Masonry( gallery, {
        itemSelector: '.masonry-item',
        percentPosition: true,
        transitionDuration: 0 // Disable animation for instant loading
      });
      // ---------------------------------
      
      // Setup context menu
      setupContextMenu();
      
      // Initial Load
      await loadTagCounts(); // <-- ADDED: Load counts first
      await loadTags();
      await loadTotalCardCount(); // <-- Load the total count on startup
      await loadCards(true); // Start with a new query
      
      // Event Listeners
      window.addEventListener('keydown', e => {
        if (e.key === "Escape") {
          closePopup();
          closeImageViewer();
          closeQuickEditModal(); // Also close the new modal
          closeManageTagsPopup(); // <-- ADDED
        }
        // Keyboard nav for viewer
        if (imageViewer.style.display === 'flex') {
          if (e.key === 'ArrowLeft') prevImage();
          if (e.key === 'ArrowRight') nextImage();
        }
      });
      
      // Add click listener to close tags dropdown
      window.addEventListener('click', (event) => {
        if (!document.getElementById('tags-dropdown-container').contains(event.target)) {
          closeTagsDropdown();
        }
      });
      
      // Add scroll event listener for infinite loading
      window.addEventListener('scroll', handleScroll);
      
      // START: Add change listener for sort order
      document.getElementById('sort-order').addEventListener('change', (event) => {
        currentSortOrder = event.target.value;
        document.getElementById('mobile-sort-order').value = currentSortOrder; // <-- Sync mobile sort
        loadCards(true); // Trigger a new search with the new sort order
      });
      // END: Add change listener
      
      // START: Add change listener for MOBILE sort order
      document.getElementById('mobile-sort-order').addEventListener('change', (event) => {
          currentSortOrder = event.target.value;
          document.getElementById('sort-order').value = currentSortOrder; // <-- Sync desktop sort
          loadCards(true); // Trigger a new search
          closeMobileMenu(); // Close menu on change
      });
      // END: Add change listener

      // Add submit listener for the new quick edit form
      document.getElementById('quickEditForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        await handleQuickUpdate();
      });
      
      // START: Add submit listener for the new tag management form
      document.getElementById('addTagForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          await handleAddNewTag();
      });
      // END: Add submit listener
      
      // START: Add resize listener to close mobile menu
      window.addEventListener('resize', () => {
          if (window.innerWidth >= 1024) { // lg breakpoint
              closeMobileMenu();
          }
      });
      // END: Add resize listener
    };
    
    // --- Data Loading ---

    // START: New function to load tag counts
    async function loadTagCounts() {
      console.log("Loading tag counts...");
      try {
        const { data: models, error } = await supabase
          .from('models')
          .select('tags'); // Only get the tags column

        if (error) throw error;

        const counts = {};
        models.forEach(model => {
          if (model.tags) {
            const tags = model.tags.split(',').map(t => t.trim()).filter(t => t);
            tags.forEach(tag => {
              counts[tag] = (counts[tag] || 0) + 1;
            });
          }
        });
        
        tagCountMap = counts; // Store globally
        console.log("Tag counts loaded:", tagCountMap);
      } catch (error) {
        console.error("Error loading tag counts:", error);
      }
    }
    // END: New function

    // START: New function to load total card count
    async function loadTotalCardCount() {
      const countEl = document.getElementById('total-card-count');
      try {
        // Use a head request with 'exact' count for performance
        const { count, error } = await supabase
          .from('models')
          .select('*', { head: true, count: 'exact' });
          
        if (error) throw error;
        
        if (countEl) {
          countEl.textContent = `(${count} total)`;
        }
      } catch (error) {
        console.error("Error loading total card count:", error);
        if (countEl) {
          countEl.textContent = `(Error)`;
        }
      }
    }
    // END: New function
    
    async function loadTags() {
      const tagsDropdownMenu = document.getElementById('tags-dropdown-menu');
      try {
        const { data: tags, error } = await supabase
          .from('tags')
          .select('name')
          .order('name', { ascending: true });

        if (error && error.code === '42P01') {
          console.error("The 'tags' table does not exist.");
          tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-gray-500">Tag setup needed</span>';
          return;
        }
        if (error) throw error;
        
        allTags = tags.map(tag => tag.name);
        updateTagDisplays(); // This is for the main upload popup
        
        // Populate header dropdown
        tagsDropdownMenu.innerHTML = ''; // Clear 'Loading...'
        if (allTags.length > 0) {
          allTags.forEach(tag => {
            // START: Do not show 'album:' tags in the dropdown
            if (tag.startsWith('album:')) { return; }
            // END: Do not show 'album:' tags
            
            const tagLink = document.createElement('a');
            tagLink.href = "#";
            tagLink.className = "block px-4 py-2 text-sm text-gray-300 hover:bg-blue-600 hover:text-white";
            
            // START: MODIFIED
            const count = tagCountMap[tag] || 0;
            tagLink.textContent = `${tag} (${count})`;
            // END: MODIFIED
            
            tagLink.onclick = (e) => {
              e.preventDefault();
              searchByTag(tag);
              closeTagsDropdown();
              closeMobileMenu(); // <-- ADD THIS
              document.getElementById('tags-dropdown-btn').classList.add('text-white');
              document.getElementById('tags-dropdown-btn').classList.remove('text-gray-400');
            };
            tagsDropdownMenu.appendChild(tagLink);
          });
        } else {
          tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-gray-500">No tags found</span>';
        }
        
      } catch (error) {
        console.error("Error loading tags:", error);
        tagsDropdownMenu.innerHTML = '<span class="block px-4 py-2 text-sm text-red-400">Error loading tags</span>';
      }
    }

    async function loadCards(isNewQuery = false) {
      if (isLoadingMore || (noMoreResults && !isNewQuery)) return;
      
      isLoadingMore = true;
      if (isNewQuery) {
        currentPage = 0;
        // Reset noMoreResults based on sort order. Shuffle mode disables pagination.
        noMoreResults = (currentSortOrder === 'shuffle');
        gallery.innerHTML = ''; // Clear gallery for new search
        displayedCards = []; // Clear displayed cards array
        albumsSeenThisSession.clear(); // <-- START: Clear album tracker
        noResults.style.display = 'none';
        searchStatus.style.display = 'none';
        loader.style.display = 'flex';
        // Only show scroll loader if we are NOT in shuffle mode
        scrollLoader.style.display = (currentSortOrder === 'shuffle') ? 'none' : 'flex';
      } else {
        // This block is for infinite scroll, which shuffle mode doesn't use
        scrollLoader.style.display = 'flex';
      }

      try {
        let query = supabase.from('models').select('*');

        // Apply filters
        switch (currentFilter.type) {
          case 'favorites':
            query = query.eq('favorited', true);
            searchStatus.innerHTML = '<h2 class="text-xl">Favorites</h2>';
            searchStatus.style.display = 'flex';
            updateNavActiveState('favorites');
            break;
          case 'nsfw':
            query = query.eq('nsfw', true);
            searchStatus.innerHTML = '<h2 class="text-xl text-red-400">NSFW Models</h2>';
            searchStatus.style.display = 'flex';
            updateNavActiveState('nsfw');
            break;
          case 'tags':
            const t = currentFilter.value.trim().replace(/"/g, '""');
            const orExpr = `tags.eq."${t}",tags.ilike."${t},%",tags.ilike."%,${t}",tags.ilike."%,${t},%"`;
            query = query.or(orExpr);
            
            // START: MODIFIED
            const count = tagCountMap[currentFilter.value] || 0;
            const countText = count === 1 ? 'model' : 'models'; // Handle plural
            searchStatus.innerHTML = `
              <div class="flex flex-wrap items-center justify-center gap-x-4 gap-y-2">
                <h2 class="text-xl">Tag: <span class="px-3 py-1 bg-gray-700 text-white text-lg rounded-full">${currentFilter.value}</span></h2>
                <span class="text-gray-500 text-lg">(${count} ${countText})</span>
              </div>
            `;
            // END: MODIFIED
            
            searchStatus.style.display = 'flex';
            updateNavActiveState('tags');
            break;
          // START: New case for 'all_albums'
          case 'all_albums':
            query = query.eq('nsfw', false);
            query = query.ilike('tags', '%album:%'); // Select ONLY albums
            searchStatus.innerHTML = '<h2 class="text-xl">Albums</h2>';
            searchStatus.style.display = 'flex';
            updateNavActiveState('all_albums');
            break;
          // END: New case
          default: // 'all_singles'
            query = query.eq('nsfw', false);
            query = query.not('tags', 'ilike', '%album:%'); // Select NOT albums
            updateNavActiveState('all_singles');
            break;
        }

        // Add pagination & ordering
        if (currentSortOrder === 'shuffle') {
          // For shuffle, we fetch one large page (e.g., 100) and disable pagination
          // We also don't apply a database order. This only runs on a new query.
          if (isNewQuery) {
            query = query.limit(100); // Fetch a single large batch
          } else {
            // This shouldn't be called, but as a fallback, ensure no cards are loaded
            cards = [];
            noMoreResults = true;
          }
        } else {
          // Standard pagination and ordering
          const from = currentPage * PAGE_SIZE;
          const to = from + PAGE_SIZE - 1;
          query = query.range(from, to);
          
          if (currentSortOrder === 'first_uploaded') {
            query = query.order('created_at', { ascending: true });
          } else { // default is 'last_uploaded'
            query = query.order('created_at', { ascending: false });
          }
        }

        let { data: cards, error } = await query;
        if (error) throw error;
        
        // START: Shuffle cards client-side if that option is selected
        if (currentSortOrder === 'shuffle' && cards) {
          shuffleArray(cards);
        }
        // END: Shuffle
        
        // Client-side filter for exact tag match (Supabase 'or' is broad)
        if (currentFilter.type === 'tags') {
           const needle = currentFilter.value.toLowerCase();
           cards = (cards || []).filter(c =>
             (c.tags || '')
               .split(',')
               .map(s => s.trim().toLowerCase())
               .includes(needle)
           );
        }
        
        loader.style.display = 'none';
        scrollLoader.style.display = 'none';
        
        // START: Modified logic for album grouping
        if (cards && cards.length > 0) {
          noResults.style.display = 'none';
          
          const newElements = []; // For Masonry
          const newCardsForGallery = []; // For `displayedCards`

          cards.forEach(card => {
            const allCardTags = (card.tags || '').split(',').map(t => t.trim()).filter(t => t);
            const albumTag = allCardTags.find(t => t.startsWith('album:'));
            
            if (albumTag) {
              card.isAlbum = true;
              card.albumTag = albumTag;
              
              // --- NEW ---
              // Try to find the matching display name tag
              const albumSlug = albumTag.substring(6); // e.g., "my-model"
              // Find a tag that, when sanitized, matches the slug.
              // This finds the *original* album name tag.
              card.albumName = allCardTags.find(t => 
                !t.startsWith('album:') && // Must not be the album: tag itself
                t.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '') === albumSlug
              );
              
              // Fallback just in case the original tag was removed
              if (!card.albumName) {
                // Capitalize the slug
                card.albumName = albumSlug.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
              }
              // --- END NEW ---
              
              if (!albumsSeenThisSession.has(albumTag)) {
                albumsSeenThisSession.add(albumTag);
                card.isAlbumCover = true; // Flag it
                newCardsForGallery.push(card); // Add to gallery
              }
              // If album *has* been seen, we just skip this card and don't display it.
            } else {
              card.isAlbum = false;
              newCardsForGallery.push(card); // It's an individual card
            }
          });
          
          // Now, `newCardsForGallery` has only 1 cover per album, + all individual cards from this page
          
          if (newCardsForGallery.length > 0) {
            newCardsForGallery.forEach(card => {
              const index = displayedCards.length; // Get index *before* adding
              displayedCards.push(card); // Store card in the global array
              
              const cardElem = createCardElement(card, index); // Create the element
              gallery.appendChild(cardElem); // Add it to the DOM
              newElements.push(cardElem); // Add to array for imagesLoaded
            });
            
            // --- New Masonry/imagesLoaded logic ---
            imagesLoaded(newElements, function() {
              if (isNewQuery) {
                // For a new search, just reload all items
                msnry.reloadItems();
              } else {
                // For infinite scroll, append the new items
                msnry.addItems(newElements);
              }
              // Trigger Masonry layout
              msnry.layout();
            });
            // --- End new logic ---
            
            // Only increment page if we are NOT in shuffle mode
            if (currentSortOrder !== 'shuffle') {
              currentPage++; // Increment page for next fetch
            }
          } else if (isNewQuery) {
             // We fetched cards, but all were filtered out (e.g., already seen albums)
             noResults.style.display = 'block';
          }
          
        } else {
          noMoreResults = true;
          if (isNewQuery) {
            noResults.style.display = 'block';
          }
        }
        // END: Modified logic for album grouping
        
      } catch (error) {
        console.error("Error loading cards:", error);
        loader.style.display = 'none';
        scrollLoader.style.display = 'none';
        noResults.innerHTML = 'Error loading models. Check console for details.';
        noResults.style.display = 'block';
      }
      
      isLoadingMore = false;
    }
    
    // START: ADDED MISSING FUNCTIONS
    
    // --- This function creates the card element ---
    function createCardElement(card, index) { // Added index
      const cardElem = document.createElement('div');
      // Added `group` class for hover effect on new edit button
      cardElem.className = 'masonry-item bg-gray-900 rounded-lg overflow-hidden relative group cursor-pointer';
      // Add an ID to the element for easy updating later
      cardElem.id = `card-dom-${card.id}`;
      
      // START: Add Album badge
      if (card.isAlbumCover) {
        const albumBadge = document.createElement('div');
        albumBadge.className = 'absolute top-2 left-2 z-10 px-2 py-0.5 bg-blue-600 text-white text-xs font-bold rounded-full opacity-0 group-hover:opacity-100 transition-opacity';
        albumBadge.textContent = 'Album';
        cardElem.appendChild(albumBadge);
      }
      // END: Add Album badge
      
      const img = document.createElement('img');
      img.src = card.main_model_url.includes('ik.imagekit.io')
        ? `${card.main_model_url}?tr=w-500,q-70`
        : card.main_model_url;
      img.alt = "Model";
      img.className = "w-full h-auto block";
      img.onerror = () => { img.src = 'https://placehold.co/500x500/111827/4b5563?text=Error'; };
      
      const overlay = document.createElement('div');
      overlay.className = "overlay absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center";
      
      const tagIcon = document.createElement('span');
      tagIcon.className = "text-white text-3xl";
      tagIcon.innerHTML = "&#9776;"; // Simple list icon
      
      // START: New Edit Button
      const editButton = document.createElement('button');
      editButton.className = "absolute top-2 right-2 z-10 p-1.5 bg-black/50 rounded-full text-white hover:bg-blue-600 opacity-0 group-hover:opacity-100 transition-opacity";
      editButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.536L16.732 3.732z" />
        </svg>
      `;
      editButton.onclick = (e) => {
        e.stopPropagation(); // Prevent opening the image viewer
        openQuickEditModal(card.id);
      };
      // END: New Edit Button
      
      // START: New Delete Button
      const deleteButton = document.createElement('button');
      deleteButton.className = "absolute top-10 right-2 z-10 p-1.5 bg-black/50 rounded-full text-white hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"; // Positioned below edit button
      deleteButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
          <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      `;
      deleteButton.onclick = (e) => {
        e.stopPropagation(); // Prevent opening the image viewer
        deleteCard(card.id); // This function already has a confirm()
      };
      // END: New Delete Button
      
      // START: New Favorite Button
      const favoriteButton = document.createElement('button');
      // Positioned below delete button. top-10 is 2.5rem. We add another 2rem (8 units) to get 4.5rem.
      // Using an arbitrary value `top-[4.5rem]` since `top-18` is not a valid class.
      const favBtnBaseClasses = "absolute top-[4.5rem] right-2 z-10 p-1.5 bg-black/50 rounded-full hover:text-yellow-400 opacity-0 group-hover:opacity-100 transition-opacity";
      const favBtnColorClass = card.favorited ? 'text-yellow-400' : 'text-white';
      favoriteButton.className = `${favBtnBaseClasses} ${favBtnColorClass}`;
      favoriteButton.id = `fav-btn-${card.id}`; // Add ID for easy selection
      favoriteButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" d="M21 8.25c0-2.485-2.099-4.5-4.688-4.5-1.935 0-3.597 1.126-4.312 2.733-.715-1.607-2.377-2.733-4.313-2.733C5.1 3.75 3 5.765 3 8.25c0 7.22 9 12 9 12s9-4.78 9-12z" />
        </svg>
      `; // Using a filled heart SVG, fill will be 'currentColor'
      
      favoriteButton.onclick = (e) => {
        e.stopPropagation(); // Prevent opening the image viewer
        // Find the current status from the displayedCards array, in case it was updated
        const currentCard = displayedCards.find(c => c.id === card.id);
        toggleFavorite(e, card.id, currentCard ? currentCard.favorited : card.favorited);
      };
      // END: New Favorite Button
      
      overlay.appendChild(tagIcon);
      cardElem.appendChild(img);
      cardElem.appendChild(overlay);
      cardElem.appendChild(editButton); // Add the edit button to the card
      cardElem.appendChild(deleteButton); // Add the delete button to the card
      cardElem.appendChild(favoriteButton); // Add the favorite button to the card

      // Main click action: Open Image Viewer
      cardElem.addEventListener('click', () => {
        openImageViewer(index); // Pass index
      });
      
      // Right-click for context menu
      cardElem.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        showContextMenu(e, card.id);
      });
      
      // gallery.appendChild(cardElem); // <-- REMOVED: Will be appended in loadCards
      return cardElem; // <-- ADDED: Return the element
    }

    // --- Infinite Scroll ---
    
    function handleScroll() {
      // Don't load if any modal is open
      if (imageViewer.style.display === 'flex' || document.getElementById('popup').style.display === 'flex' || document.getElementById('quick-edit-modal').style.display === 'flex' || document.getElementById('manage-tags-popup').style.display === 'flex') return; // <-- ADDED
      
      // START: Disable infinite scroll if in shuffle mode
      if (currentSortOrder === 'shuffle') return;
      // END: Disable
      
      const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
      if (scrollTop + clientHeight >= scrollHeight - 300) {
        if (!isLoadingMore && !noMoreResults) {
          loadCards();
        }
      }
    }
    
    // Infinite scroll for RELATED items (listens to modal scroll)
    function handleRelatedScroll() {
      // START: Check if currentRelatedCard is null or an album
      if (!currentRelatedCard || currentRelatedCard.isAlbum) return;
      // END
      
      const { scrollTop, scrollHeight, clientHeight } = imageViewer;
      if (scrollTop + clientHeight >= scrollHeight - 300) {
        if (!relatedIsLoadingMore && !relatedNoMoreResults) {
          loadRelatedImages(currentRelatedCard, false); // false = not a new query
        }
      }
    }
    
    // --- Navigation & Filtering ---
    
    function updateNavActiveState(state = null) {
        document.querySelector('a[href="#"]').classList.remove('text-white', 'font-semibold');
        document.querySelector('a[href="#"]').classList.add('text-gray-400');
        
        // START: Add albums link
        document.getElementById('albums-link').classList.remove('text-white', 'font-semibold');
        document.getElementById('albums-link').classList.add('text-gray-400');
        // END: Add albums link
        
        document.querySelector('a[onclick*="showFavorites"]').classList.remove('text-white', 'font-semibold');
        document.querySelector('a[onclick*="showFavorites"]').classList.add('text-gray-400');
        
        document.getElementById('nsfwBtn').classList.remove('text-white', 'font-semibold');
        document.getElementById('nsfwBtn').classList.add('text-gray-400');
        
        // Handle Tags button
        document.getElementById('tags-dropdown-btn').classList.remove('text-white');
        document.getElementById('tags-dropdown-btn').classList.add('text-gray-400');

        if (state === 'all_singles') {
            document.querySelector('a[href="#"]').classList.add('text-white', 'font-semibold');
        } else if (state === 'all_albums') {
            document.getElementById('albums-link').classList.add('text-white', 'font-semibold');
        } else if (state === 'favorites') {
            document.querySelector('a[onclick*="showFavorites"]').classList.add('text-white', 'font-semibold');
        } else if (state === 'nsfw') {
            document.getElementById('nsfwBtn').classList.add('text-white', 'font-semibold');
        } else if (state === 'tags') {
            document.getElementById('tags-dropdown-btn').classList.add('text-white');
            document.getElementById('tags-dropdown-btn').classList.remove('text-gray-400');
        }
    }

    function showAllModels(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'all_singles', value: null };
      loadCards(true);
    }

    // START: New function for showAllAlbums
    function showAllAlbums(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'all_albums', value: null };
      loadCards(true);
    }
    // END: New function

    function showFavorites(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'favorites', value: null };
      loadCards(true);
    }

    function showNsfw(event) {
      if(event) event.preventDefault();
      currentFilter = { type: 'nsfw', value: null };
      loadCards(true);
    }
    
    function searchByTag(tag) {
      closeImageViewer();
      currentFilter = { type: 'tags', value: tag };
      loadCards(true);
    }
    
    // END: ADDED MISSING FUNCTIONS

    // --- START: Mobile Menu Functions ---
    function toggleMobileMenu() {
        mobileMenu.classList.toggle('hidden');
        const menuBtn = document.getElementById('menu-btn');
        if (mobileMenu.classList.contains('hidden')) {
            // Change to hamburger
            menuBtn.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>`;
        } else {
            // Change to 'X'
            menuBtn.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
        }
    }
    
    function closeMobileMenu() {
        if (!mobileMenu.classList.contains('hidden')) {
            mobileMenu.classList.add('hidden');
            const menuBtn = document.getElementById('menu-btn');
            // Change back to hamburger
            menuBtn.innerHTML = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>`;
        }
    }
    
    // Wrapper for mobile menu clicks
    function mobileMenuClicked(functionName) {
        // Pass the event to the functions that need it
        const event = window.event;
        
        // Find the function by name and call it
        switch (functionName) {
            case 'showAllModels':
                showAllModels(event);
                break;
            case 'showAllAlbums':
                showAllAlbums(event);
                break;
            case 'showFavorites':
                showFavorites(event);
                break;
            case 'showNsfw':
                showNsfw(event);
                break;
            case 'openManageTagsPopup':
                openManageTagsPopup();
                break;
            // Add other functions here if needed
        }
        // Close the menu after action
        closeMobileMenu();
    }
    // --- END: Mobile Menu Functions ---

    // START: ADDING MISSING FUNCTION
    function toggleTagsDropdown(event) {
      event.stopPropagation(); // Prevent window.click from closing it
      const menu = document.getElementById('tags-dropdown-menu');
      menu.classList.toggle('hidden');
      
      const btn = document.getElementById('tags-dropdown-btn');
      if (!menu.classList.contains('hidden')) {
        // If opening, always set to active
        btn.classList.add('text-white');
        btn.classList.remove('text-gray-400');
      } else {
        // If closing, only remove active if not in tag filter mode
        if (currentFilter.type !== 'tags') {
           btn.classList.remove('text-white');
           btn.classList.add('text-gray-400');
        }
      }
    }
    // END: ADDING MISSING FUNCTION

    function closeTagsDropdown() {
      document.getElementById('tags-dropdown-menu').classList.add('hidden');
      // Only remove 'text-white' if not actively filtering by tag
      const btn = document.getElementById('tags-dropdown-btn');
      if (currentFilter.type !== 'tags') {
         btn.classList.remove('text-white');
         btn.classList.add('text-gray-400');
      }
    }

    function openImageViewer(index) { // Takes index
      imageViewer.style.display = 'flex';
      imageViewer.scrollTop = 0; // Scroll modal to top
      
      // Add event listeners for viewer interactions
      imageViewer.addEventListener('scroll', handleRelatedScroll); // Listen to modal scroll
      document.addEventListener('wheel', handleViewerWheel, { passive: false });
      viewerImageContainer.addEventListener('mousedown', handleViewerMouseDown);
      document.addEventListener('mousemove', handleViewerMouseMove);
      document.addEventListener('mouseup', handleViewerMouseUp);
      viewerImageContainer.addEventListener('touchstart', handleViewerTouchStart, { passive: false });
      viewerImageContainer.addEventListener('touchmove', handleViewerTouchMove, { passive: false });
      viewerImageContainer.addEventListener('touchend', handleViewerTouchEnd);
      
      currentViewerIndex = index;
      const card = displayedCards[index];
      if (card) {
        displayCardInViewer(card);
      } else {
        console.error("Could not find card at index:", index);
        closeImageViewer();
      }
    }

    function closeImageViewer(event = null) {
      if (event) {
        // Only close if the click is on the backdrop, not children
        if (event.target !== imageViewer) { return; }
      }
      if (imageViewer.style.display === 'flex') {
        imageViewer.style.display = 'none';
        viewerImage.src = ''; // Stop image loading
        
        // Remove event listeners
        imageViewer.removeEventListener('scroll', handleRelatedScroll);
        document.removeEventListener('wheel', handleViewerWheel);
        viewerImageContainer.removeEventListener('mousedown', handleViewerMouseDown);
        document.removeEventListener('mousemove', handleViewerMouseMove);
        document.removeEventListener('mouseup', handleViewerMouseUp);
        viewerImageContainer.removeEventListener('touchstart', handleViewerTouchStart);
        viewerImageContainer.removeEventListener('touchmove', handleViewerTouchMove);
        viewerImageContainer.removeEventListener('touchend', handleViewerTouchEnd);
        
        resetZoom(); // Reset for next time
      }
    }
    
    // Display card data in the (already open) viewer
    function displayCardInViewer(card) {
      imageViewer.scrollTop = 0; // Scroll to top when loading new image
      resetZoom(); // Reset zoom/pan for new image
      viewerLoader.style.display = 'flex';
      viewerImage.style.display = 'none';
      viewerTags.innerHTML = '';
      
      const nsfwLabel = document.getElementById('viewer-nsfw-label');

      const fullResUrl = card.main_model_url.includes('ik.imagekit.io')
        ? card.main_model_url.split('?')[0] + '?tr=q-90'
        : card.main_model_url;
      
      viewerImage.src = fullResUrl;
      viewerImage.onload = () => {
        viewerLoader.style.display = 'none';
        viewerImage.style.display = 'block';
        applyViewerTransform(); // Apply reset zoom/pan
      };
      
      viewerImage.onerror = () => {
        viewerLoader.style.display = 'none';
        viewerImage.style.display = 'block';
        viewerImage.src = 'https://placehold.co/800x800/111827/4b5563?text=Error+Loading+Image';
        applyViewerTransform();
      };

      if (card.nsfw) nsfwLabel.style.display = 'inline-block';
      else nsfwLabel.style.display = 'none';

      const tags = card.tags ? card.tags.split(',').map(t => t.trim()).filter(t => t) : [];
      if (tags.length > 0) {
        tags.forEach(tag => {
          // START: Don't show album tags as clickable buttons
          if (tag.startsWith('album:')) {
            const tagElem = document.createElement('span');
            tagElem.className = "px-3 py-1 bg-gray-800 text-gray-400 text-sm rounded-full";
            // Clean up the name for display
            tagElem.textContent = tag.substring(6).replace(/-/g, ' ');
            viewerTags.appendChild(tagElem);
            return; // Skip to next tag
          }
          // END: Don't show album tags
          
          const tagElem = document.createElement('button');
          tagElem.className = "px-3 py-1 bg-gray-700 text-white text-sm rounded-full hover:bg-blue-600 transition-colors";
          tagElem.textContent = tag;
          tagElem.onclick = () => searchByTag(tag);
          viewerTags.appendChild(tagElem);
        });
      } else {
        viewerTags.innerHTML = `<span class="text-gray-400 text-sm">No tags for this model.</span>`;
      }
      
      // START: Modified to load album or related
      const addToAlbumBtn = document.getElementById('add-to-album-btn');
      const relatedTitle = document.getElementById('viewer-related-container').querySelector('h4');
      
      if (card.isAlbum) {
        // This is an album card, load the album images instead of "related"
        relatedTitle.textContent = 'Images in this Album';
        addToAlbumBtn.style.display = 'flex'; // <-- SHOW BUTTON
        loadAlbumImages(card.albumTag, card.id);
      } else {
        // This is an individual card, load related by tags
        relatedTitle.textContent = 'Related Models';
        addToAlbumBtn.style.display = 'none'; // <-- HIDE BUTTON
        loadRelatedImages(card, true); // true = new query
      }
      // END: Modified
    }
    
    // START: New function to load album images
    async function loadAlbumImages(albumTag, currentCardId) {
      if (!albumTag) { return; }
      
      // Store card to prevent related scroll
      currentRelatedCard = { isAlbum: true }; 
      
      relatedIsLoadingMore = true; // Prevent other loads
      relatedCurrentPage = 0; // Reset
      relatedNoMoreResults = true; // No pagination for albums for now
      
      const relatedContainer = document.getElementById('viewer-related-container');
      // relatedContainer.querySelector('h4').textContent = 'Images in this Album'; // Change title - REMOVED, handled by displayCardInViewer
      viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">Loading album...</span>';
      relatedScrollLoader.style.display = 'none'; // Hide scroll loader

      try {
        // Fetch all other images in this album
        const { data: albumCards, error } = await supabase
          .from('models')
          .select('*')
          .ilike('tags', `%${albumTag}%`)  // Find all with the album tag
          .neq('id', currentCardId) // Exclude the image we're currently viewing
          .order('created_at', { ascending: true }) // Show in upload order
          .limit(50); // Limit to 50 for now
          
        if (error) throw error;
        
        viewerRelatedGrid.innerHTML = ''; // Clear loading
        
        if (albumCards.length === 0) {
          viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">No other images found in this album.</span>';
        } else {
          // Re-use the existing function to add cards to the grid
          albumCards.forEach(addRelatedCardToGrid); 
        }
        
      } catch (error) {
        console.error("Error loading album images:", error);
        viewerRelatedGrid.innerHTML = '<span class="text-red-400 text-sm col-span-full">Error loading album.</span>';
      }
      
      relatedIsLoadingMore = false;
    }
    // END: New function
    
    // Load related images into the bottom strip
    async function loadRelatedImages(card, isNewQuery = true) {
      if (!card) { return; }
      
      // START: Reset title - REMOVED
      // const relatedContainer = document.getElementById('viewer-related-container');
      // relatedContainer.querySelector('h4').textContent = 'Related Models';
      // END: Reset title
      
      // Prevent loading if already loading
      if (relatedIsLoadingMore) return;
      
      // Store the card we're basing this search on
      currentRelatedCard = card; 
      
      if (isNewQuery) {
        relatedCurrentPage = 0;
        relatedNoMoreResults = false;
        viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">Loading...</span>';
      } else {
        relatedScrollLoader.style.display = 'flex';
      }
      
      relatedIsLoadingMore = true;

      const tags = card.tags ? card.tags.split(',').map(t => t.trim()).filter(t => t && !t.startsWith('album:')) : []; // <-- Don't use album tags for related
      if (tags.length === 0) {
        viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">No tags to find related models.</span>';
        relatedIsLoadingMore = false;
        relatedNoMoreResults = true;
        relatedScrollLoader.style.display = 'none';
        return;
      }
      
      try {
        const tagConditions = tags.map(tag => {
          const t = tag.trim().replace(/"/g, '""');
          return `tags.ilike.%${t}%`;
        }).join(',');
        
        const { data: relatedCards, error } = await supabase
          .from('models')
          .select('*')
          .or(tagConditions)
          .neq('id', card.id) // Exclude self
          .eq('nsfw', false) // Keep related SFW
          .limit(PAGE_SIZE) // Use same page size
          .range(relatedCurrentPage * PAGE_SIZE, (relatedCurrentPage + 1) * PAGE_SIZE - 1); // Pagination
          
        if (error) throw error;
        
        // START: Shuffle related cards
        if (relatedCards) shuffleArray(relatedCards);
        // END: Shuffle related cards
        
        relatedScrollLoader.style.display = 'none';
        
        if (isNewQuery) {
          viewerRelatedGrid.innerHTML = ''; // Clear loading
        }
        
        if (relatedCards.length === 0) {
          if (isNewQuery) {
            viewerRelatedGrid.innerHTML = '<span class="text-gray-500 text-sm col-span-full">No related models found.</span>';
          }
          relatedNoMoreResults = true;
        } else {
          relatedCards.forEach(addRelatedCardToGrid);
          relatedCurrentPage++;
        }
        
      } catch (error) {
        console.error("Error loading related images:", error);
        relatedScrollLoader.style.display = 'none';
        if (isNewQuery) {
          viewerRelatedGrid.innerHTML = '<span class="text-red-400 text-sm col-span-full">Error loading related models.</span>';
        }
      }
      
      relatedIsLoadingMore = false;
    }
    
    // Function to create and add a related card to the new grid
    function addRelatedCardToGrid(relatedCard) {
      const cardElem = document.createElement('div');
      cardElem.className = 'related-masonry-item bg-gray-900 rounded-lg overflow-hidden relative group cursor-pointer';
      
      const img = document.createElement('img');
      img.src = relatedCard.main_model_url.includes('ik.imagekit.io')
        ? `${relatedCard.main_model_url}?tr=w-500,q-70` // Larger preview
        : relatedCard.main_model_url;
      img.alt = "Related Model";
      img.className = "w-full h-auto block";
      img.onerror = () => { img.src = 'https://placehold.co/500x500/111827/4b5563?text=Error'; };
      
      cardElem.appendChild(img);
      
      cardElem.onclick = () => {
        // START: Find index in *gallery* list first
        const relatedIndex = displayedCards.findIndex(card => card.id === relatedCard.id);
        
        // Find album tag
        const albumTag = (relatedCard.tags || '').split(',').map(t => t.trim()).find(t => t.startsWith('album:'));
        if (albumTag) {
          relatedCard.isAlbum = true;
          relatedCard.albumTag = albumTag;
        }
        // END: Find album tag
        
        if (relatedIndex !== -1) {
          // If it's in our main gallery list, just jump to it
          currentViewerIndex = relatedIndex;
          displayCardInViewer(displayedCards[relatedIndex]); // Use the full object
        } else {
          // If it's not in the main list, just display its data
          // (Next/Prev will still be tied to the main gallery)
          displayCardInViewer(relatedCard);
        }
      };
      
      viewerRelatedGrid.appendChild(cardElem);
    }
    
    // --- Viewer Navigation ---
    
    function prevImage(event = null) {
      if(event) event.stopPropagation();
      currentViewerIndex = (currentViewerIndex - 1 + displayedCards.length) % displayedCards.length;
      displayCardInViewer(displayedCards[currentViewerIndex]);
    }
    
    function nextImage(event = null) {
      if(event) event.stopPropagation();
      currentViewerIndex = (currentViewerIndex + 1) % displayedCards.length;
      displayCardInViewer(displayedCards[currentViewerIndex]);
    }

    // --- Viewer Zoom/Pan ---
    
    function zoomIn(event = null) {
      if(event) event.stopPropagation();
      viewerScale = Math.min(viewerScale * 1.5, 10);
      applyViewerTransform();
    }
    
    function zoomOut(event = null) {
      if(event) event.stopPropagation();
      viewerScale = Math.max(viewerScale / 1.5, 0.5);
      applyViewerTransform();
    }
    
    function resetZoom(event = null) {
      if(event) event.stopPropagation();
      viewerScale = 1;
      viewerPosX = 0;
      viewerPosY = 0;
      applyViewerTransform();
    }
    
    function applyViewerTransform() {
      // Fit to container logic
      const containerWidth = viewerImageContainer.clientWidth;
      const containerHeight = viewerImageContainer.clientHeight;
      const imgWidth = viewerImage.naturalWidth;
      const imgHeight = viewerImage.naturalHeight;

      if (!imgWidth || !imgHeight) {
         // Image not loaded yet, just center
         viewerImage.style.transform = `translate(-50%, -50%) translate(${viewerPosX}px, ${viewerPosY}px) scale(${viewerScale})`;
         return;
      }

      let baseScale = 1;
      if (viewerScale === 1) {
        // Fit logic (like 'contain')
        baseScale = Math.min(containerWidth / imgWidth, containerHeight / imgHeight);
        viewerPosX = 0; // Reset position when fitting
        viewerPosY = 0;
      } else {
        // Use the 'fit' scale as the base for zooming
        baseScale = Math.min(containerWidth / imgWidth, containerHeight / imgHeight);
      }
      
      const effectiveScale = baseScale * viewerScale;
      
      // Apply transform from 50, 50 anchor
      viewerImage.style.transform = `translate(-50%, -50%) translate(${viewerPosX}px, ${viewerPosY}px) scale(${effectiveScale})`;
    }
    
    function handleViewerWheel(e) {
      if (e.ctrlKey) {
        e.preventDefault();
        const delta = -e.deltaY;
        if (delta > 0) zoomIn();
        else zoomOut();
      }
    }
    
    // --- Mouse Pan Handlers ---
    function handleViewerMouseDown(e) {
      e.preventDefault();
      isViewerDragging = true;
      viewerStartDrag = { x: e.clientX - viewerPosX, y: e.clientY - viewerPosY };
      viewerImageContainer.classList.add('grabbing');
    }
    
    function handleViewerMouseMove(e) {
      if (isViewerDragging) {
        e.preventDefault();
        viewerPosX = e.clientX - viewerStartDrag.x;
        viewerPosY = e.clientY - viewerStartDrag.y;
        applyViewerTransform();
      }
    }

    function handleViewerMouseUp() {
      isViewerDragging = false;
      viewerImageContainer.classList.remove('grabbing');
    }
    
    // --- Touch Handlers (Pinch/Pan/Swipe) ---
    function handleViewerTouchStart(e) {
      if (e.touches.length === 2) {
        // Pinch start
        e.preventDefault();
        initialPinchDistance = getPinchDistance(e.touches);
      } else if (e.touches.length === 1) {
        // Pan or Swipe start
        isViewerDragging = true;
        viewerStartDrag = { x: e.touches[0].clientX - viewerPosX, y: e.touches[0].clientY - viewerPosY };
        touchStartX = e.touches[0].clientX;
        touchEndX = e.touches[0].clientX; // Reset
      }
    }
    
    function handleViewerTouchMove(e) {
      if (e.touches.length === 2) {
        // Pinching
        e.preventDefault();
        if (initialPinchDistance === null) return;
        
        const newDistance = getPinchDistance(e.touches);
        const scaleFactor = newDistance / initialPinchDistance;
        initialPinchDistance = newDistance; // Update for next move
        
        const newScale = viewerScale * scaleFactor;
        
        // Clamp scale
        viewerScale = Math.min(Math.max(newScale, 0.5), 10);
        applyViewerTransform();
        
      } else if (e.touches.length === 1 && isViewerDragging) {
        // Panning
        if (viewerScale > 1) { // Only pan if zoomed
          e.preventDefault();
          viewerPosX = e.touches[0].clientX - viewerStartDrag.x;
          viewerPosY = e.touches[0].clientY - viewerStartDrag.y;
          applyViewerTransform();
        }
        // Track for swipe
        touchEndX = e.touches[0].clientX;
      }
    }
    
    function handleViewerTouchEnd(e) {
      if (e.touches.length === 0) {
        if (isViewerDragging) {
          // Check for swipe
          const swipeDistance = touchEndX - touchStartX;
          if (viewerScale === 1 && Math.abs(swipeDistance) > 50) { // Only swipe if not zoomed
            if (swipeDistance > 50) {
              prevImage(); // Swipe right
            } else {
              nextImage(); // Swipe left
            }
          }
        }
        
        // Reset all states
        isViewerDragging = false;
        initialPinchDistance = null;
        touchStartX = 0;
        touchEndX = 0;
      }
    }
    
    function getPinchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    
    // --- Context Menu ---
    
    function setupContextMenu() {
      const menu = document.getElementById('context-menu');
      const editBtn = document.getElementById('context-edit');
      const deleteBtn = document.getElementById('context-delete');
      let currentCardId = null;

      window.addEventListener('click', () => {
        menu.style.display = 'none';
      }, true); // Use capture to hide on any click

      editBtn.onclick = () => {
        if (currentCardId) startEditCard(currentCardId);
      };
      
      deleteBtn.onclick = () => {
        if (currentCardId) deleteCard(currentCardId);
      };
      
      window.showContextMenu = (event, cardId) => {
        event.preventDefault();
        event.stopPropagation();
        currentCardId = cardId;
        menu.style.top = `${event.clientY}px`;
        menu.style.left = `${event.clientX}px`;
        menu.style.display = 'block';
      };
    }
    
    // --- Popup & CRUD ---

    function openPopup() {
      document.getElementById('popup').style.display = 'flex';
      updateTagDisplays(); // Re-populate tags dropdown
    }

    function closePopup() {
      document.getElementById('popup').style.display = 'none';
      resetForm();
    }
    
    function resetForm() {
      document.getElementById('cardForm').reset();
      selectedTags = [];
      currentlyEditingCardId = null;
      document.getElementById('popupTitle').textContent = 'Add New Model(s)';
      document.getElementById('modelUrl').placeholder = "Enter one or more image URLs, separated by commas";
      document.getElementById('modelAlbumName').value = ''; // <-- START: Reset album name
      document.getElementById('modelAlbumName').style.display = 'block'; // <-- Show album name field
      document.getElementById('modelNsfw').checked = false;
      updateSelectedTagsDisplay();
      updateTagDisplays();
      document.getElementById('errorMessage').textContent = '';
    }

    async function addCard() {
      const errorMessage = document.getElementById('errorMessage');
      try {
        const modelUrlsText = document.getElementById('modelUrl').value.trim();
        if (!modelUrlsText) throw new Error("Image URL(s) are required.");

        const urls = modelUrlsText.split(',').map(url => url.trim()).filter(url => url.length > 0);
        if (urls.length === 0) throw new Error("Please provide at least one valid image URL.");
        
        // START: Album logic
        const albumName = document.getElementById('modelAlbumName').value.trim();
        let albumTag = null;
        if (albumName) {
          // Create a sanitized tag
          albumTag = 'album:' + albumName.toLowerCase()
            .replace(/\s+/g, '-') // Replace spaces with dashes
            .replace(/[^a-z0-9-]/g, ''); // Remove special chars
          
          if (!selectedTags.includes(albumTag)) {
            selectedTags.push(albumTag);
          }
          
          // Also add the album name as a regular tag
          /* REMOVED THIS BLOCK - We no longer add the album name as a regular tag
          if (!allTags.includes(albumName)) {
             await supabase.from('tags').insert({ name: albumName });
             // We don't need to await refreshTagData() here, just add it for this session
             allTags.push(albumName);
          }
          if (!selectedTags.includes(albumName)) {
            selectedTags.push(albumName);
          }
          */
        }
        // END: Album logic
        
        const isNsfw = document.getElementById('modelNsfw').checked;
        const tagsString = selectedTags.join(', ');

        const newCards = urls.map(url => ({
          tags: tagsString,
          main_model_url: url,
          related_models: [], // These are old/unused but good to init
          related_models_with_tags: [], // "
          favorited: false,
          nsfw: isNsfw
        }));

        const { error } = await supabase.from('models').insert(newCards);
        if (error) throw error;

        closePopup();
        await loadTotalCardCount(); // <-- Refresh count after adding
        await refreshTagData(); // <-- ADDED
        
        // START: Go to the right view
        if (albumName) {
            showAllAlbums(); // Go to albums view
        } else {
            showAllModels(); // Refresh singles view
        }
        // END: Go to the right view
        
      } catch (error) {
        console.error("Error adding card:", error);
        errorMessage.textContent = `Failed to add model(s): ${error.message}`;
      }
    }
    
    async function startEditCard(cardId) {
      try {
        const { data: card, error } = await supabase.from('models').select('*').eq('id', cardId).single();
        if (error) throw error;

        currentlyEditingCardId = cardId;
        const modelUrlInput = document.getElementById('modelUrl');
        modelUrlInput.value = card.main_model_url;
        // START: Hide album name on edit, as edit is per-image
        document.getElementById('modelAlbumName').style.display = 'none';
        // END: Hide
        
        selectedTags = card.tags ? card.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        document.getElementById('modelNsfw').checked = card.nsfw;
        
        updateSelectedTagsDisplay();
        document.getElementById('popupTitle').textContent = 'Edit Model';
        openPopup();
      } catch (error) {
        console.error("Error loading card for edit:", error);
        alert("Failed to load card for editing");
      }
    }

    async function updateCard() {
      const errorMessage = document.getElementById('errorMessage');
      try {
        const modelUrl = document.getElementById('modelUrl').value.trim();
        if (!modelUrl || modelUrl.includes(',')) {
            throw new Error("A single, valid Model URL is required when editing.");
        }
        
        const isNsfw = document.getElementById('modelNsfw').checked;
        const tagsString = selectedTags.join(', ');

        const { error } = await supabase
          .from('models')
          .update({ 
            main_model_url: modelUrl,
            tags: tagsString,
            nsfw: isNsfw
          })
          .eq('id', currentlyEditingCardId);
        
        if (error) throw error;
        
        closePopup();
        await refreshTagData(); // <-- ADDED
        loadCards(true); // Force a full refresh
      } catch (error) {
        console.error("Error updating card:", error);
        errorMessage.textContent = error.message;
      }
    }

    async function deleteCard(cardId) {
      // We don't need a custom modal, browser confirm is fine here
      if (!confirm("Are you sure you want to delete this model?")) { return; }
      try {
        const { error } = await supabase.from('models').delete().eq('id', cardId);
        if (error) throw error;
        await loadTotalCardCount(); // <-- Refresh count after deleting
        await refreshTagData(); // <-- ADDED
        loadCards(true); // Force a full refresh
      } catch (error) {
        console.error("Error deleting card:", error);
        alert("Failed to delete card");
      }
    }
    
    // START: New Toggle Favorite Function
    async function toggleFavorite(event, cardId, currentStatus) {
      const button = event.currentTarget;
      
      try {
        const { data: updatedCard, error } = await supabase
          .from('models')
          .update({ favorited: !currentStatus })
          .eq('id', cardId)
          .select()
          .single();
          
        if (error) throw error;

        // --- Start Local Data & UI Update ---
        
        // 1. Update the main `displayedCards` array
        const index = displayedCards.findIndex(c => c.id == cardId);
        if (index !== -1) {
          // Manually update properties, preserving album flags
          displayedCards[index].favorited = updatedCard.favorited;
        }
        
        // 2. Update the button color
        if (button) {
          if (updatedCard.favorited) {
            button.classList.add('text-yellow-400');
            button.classList.remove('text-white');
          } else {
            button.classList.remove('text-yellow-400');
            button.classList.add('text-white');
          }
        }
        
        // 3. If on "Favorites" tab and card is unfavorited, remove it from view
        if (currentFilter.type === 'favorites' && !updatedCard.favorited) {
          const cardElem = document.getElementById(`card-dom-${cardId}`);
          if (cardElem) {
            msnry.remove(cardElem);
            msnry.layout();
          }
          // Also remove from displayedCards
          if (index !== -1) {
            displayedCards.splice(index, 1);
          }
        }
        
        // 4. Update the viewer IF it's open and showing this card
        if (imageViewer.style.display === 'flex' && currentViewerIndex === index) {
          displayCardInViewer(displayedCards[index]);
        }
        
        // --- End Local Data & UI Update ---
        
      } catch (error) {
        console.error("Error toggling favorite:", error);
        // Optionally revert button color if update fails
        if (button) {
          if (currentStatus) { // Revert to original state
            button.classList.add('text-yellow-400');
            button.classList.remove('text-white');
          } else {
            button.classList.remove('text-yellow-400');
            button.classList.add('text-white');
          }
        }
      }
    }
    // END: New Toggle Favorite Function
    
    // Popup form submit handler
    document.getElementById('cardForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      if (currentlyEditingCardId) {
        await updateCard();
      } else {
        await addCard();
      }
    });

    // --- Tag Selection UI (Main Upload) ---

    function updateTagDisplays() {
      const availableTagsSelect = document.getElementById('availableTags');
      availableTagsSelect.innerHTML = '<option value="">Select tags to add</option>';
      allTags.forEach(tag => {
        // START: Don't show album tags in dropdown
        if (tag.startsWith('album:')) { return; }
        // END
        
        if (!selectedTags.includes(tag)) {
          const option = document.createElement('option');
          option.value = tag;
          option.textContent = tag;
          availableTagsSelect.appendChild(option);
        }
      });
    }

    function addTagToSelection() {
      const select = document.getElementById('availableTags');
      const selectedTag = select.value;
      if (!selectedTag || selectedTags.includes(selectedTag)) { return; }
      
      selectedTags.push(selectedTag);
      updateSelectedTagsDisplay();
      updateTagDisplays(); // Re-populates the dropdown
      select.value = ""; // Reset dropdown
    }
    
    function updateSelectedTagsDisplay() {
      const container = document.getElementById('selectedTagsContainer');
      container.innerHTML = '';
      selectedTags.forEach(tag => {
        // START: Don't allow removing album tags
        const isAlbumTag = tag.startsWith('album:');
        
        const tagElem = document.createElement('span');
        tagElem.className = `px-3 py-1 ${isAlbumTag ? 'bg-gray-700 text-gray-400' : 'bg-blue-600 text-white'} text-sm rounded-full flex items-center gap-2`;
        
        let removeButton = '';
        if (!isAlbumTag) {
          removeButton = `<button type="button" class="text-blue-200 hover:text-white" onclick="removeSelectedTag('${tag}')">&times;</button>`;
        }
        
        const displayName = isAlbumTag ? `Album: ${tag.substring(6).replace(/-/g, ' ')}` : tag;
        
        tagElem.innerHTML = `${displayName} ${removeButton}`;
        container.appendChild(tagElem);
        // END
      });
    }

    function removeSelectedTag(tagToRemove) {
      selectedTags = selectedTags.filter(tag => tag !== tagToRemove);
      updateSelectedTagsDisplay();
      updateTagDisplays(); // Re-populates the dropdown
    }
    
    // --- START: Tag Management Modal Functions ---

    function openManageTagsPopup() {
      document.getElementById('manage-tags-popup').style.display = 'flex';
      document.getElementById('manageTagsErrorMessage').style.display = 'none';
      document.getElementById('newTagName').value = '';
      loadTagsForManagement();
    }

    function closeManageTagsPopup() {
      document.getElementById('manage-tags-popup').style.display = 'none';
    }

    async function loadTagsForManagement() {
      const container = document.getElementById('existingTagsListContainer');
      container.innerHTML = '<span class="text-gray-500">Loading...</span>';
      
      try {
        // Fetch fresh tags list
        const { data: tags, error } = await supabase
          .from('tags')
          .select('name')
          .order('name', { ascending: true });
          
        if (error) throw error;

        if (!tags || tags.length === 0) {
          container.innerHTML = '<span class="text-gray-500">No tags found.</span>';
          return;
        }

        container.innerHTML = ''; // Clear loading
        
        tags.forEach(tagObj => {
          const tag = tagObj.name; // Get the name string
          
          // START: Don't show album tags in management
          if (tag.startsWith('album:')) { return; }
          // END
          
          const tagRow = document.createElement('div');
          tagRow.className = 'flex items-center gap-2 p-2 rounded hover:bg-gray-700';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.value = tag;
          checkbox.className = 'manage-tag-checkbox w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 focus:ring-2 focus:ring-blue-500';
          checkbox.id = `tag-cb-${tag}`;
          
          const tagNameLabel = document.createElement('label');
          tagNameLabel.className = 'text-sm text-gray-300 cursor-pointer';
          tagNameLabel.textContent = tag;
          tagNameLabel.htmlFor = `tag-cb-${tag}`;
          
          tagRow.appendChild(checkbox);
          tagRow.appendChild(tagNameLabel);
          container.appendChild(tagRow);
        });
        
      } catch (error) {
        console.error("Error loading tags for management:", error);
        container.innerHTML = '<span class="text-red-400">Error loading tags.</span>';
      }
    }
    
    // START: New helper functions for multi-select
    function getSelectedManageTags() {
      const checkboxes = document.querySelectorAll('#existingTagsListContainer .manage-tag-checkbox:checked');
      return Array.from(checkboxes).map(cb => cb.value);
    }

    function selectAllManageTags(isSelected) {
      const checkboxes = document.querySelectorAll('#existingTagsListContainer .manage-tag-checkbox');
      checkboxes.forEach(cb => cb.checked = isSelected);
    }
    // END: New helper functions

    async function handleAddNewTag() {
      const input = document.getElementById('newTagName');
      const errorMsg = document.getElementById('manageTagsErrorMessage');
      const newTagName = input.value.trim();

      if (!newTagName) {
        errorMsg.textContent = 'Tag name cannot be empty.';
        errorMsg.style.display = 'block';
        return;
      }
      
      // START: Prevent adding album tags manually
      if (newTagName.startsWith('album:')) {
        errorMsg.textContent = 'Tags cannot start with "album:".';
        errorMsg.style.display = 'block';
        return;
      }
      // END
      
      // We must check against allTags, which is kept in sync by loadTags()
      if (allTags.map(t => t.toLowerCase()).includes(newTagName.toLowerCase())) {
        errorMsg.textContent = 'This tag already exists.';
        errorMsg.style.display = 'block';
        return;
      }

      try {
        errorMsg.style.display = 'none';
        
        const { error } = await supabase
          .from('tags')
          .insert({ name: newTagName });
          
        if (error) throw error;
        
        // Success
        input.value = ''; // Clear input
        await refreshTagData(); // <-- REPLACED loadTags()
        await loadTagsForManagement(); // Refresh the list in the modal
        
      } catch (error) {
        console.error("Error adding new tag:", error);
        errorMsg.textContent = `Failed to add tag: ${error.message}`;
        errorMsg.style.display = 'block';
      }
    }

    // START: Replaced deleteTag with multi-delete
    async function handleDeleteSelectedTags() {
      const selectedTags = getSelectedManageTags();
      const errorMsg = document.getElementById('manageTagsErrorMessage');
      if (selectedTags.length === 0) {
        errorMsg.textContent = 'Please select at least one tag to delete.';
        errorMsg.style.display = 'block';
        return;
      }

      if (!confirm(`Are you sure you want to delete ${selectedTags.length} tag(s)? This will also remove the tag from all models.`)) {
        return;
      }

      try {
        errorMsg.style.display = 'none';
        
        // 1. Delete from 'tags' table
        const { error: deleteTagsError } = await supabase
          .from('tags')
          .delete()
          .in('name', selectedTags);
          
        if (deleteTagsError) throw deleteTagsError;

        // 2. Remove tags from all models
        // We need to do this for each tag
        for (const tagToDelete of selectedTags) {
            // UPDATED: Changed .eq. to .ilike. for case-insensitivity
            const orQuery = `tags.ilike."${tagToDelete}",tags.ilike."${tagToDelete},%",tags.ilike."%,${tagToDelete}",tags.ilike."%,${tagToDelete},%"`;
            const { data: models, error: fetchModelsError } = await supabase
                .from('models')
                .select() // <-- ADDED .select()
                .or(orQuery);

            if (fetchModelsError) throw new Error(`Error fetching models for tag ${tagToDelete}: ${fetchModelsError.message}`);

            if (models && models.length > 0) {
                const updates = models.map(model => {
                    let modelTags = (model.tags || '').split(',').map(t => t.trim()).filter(t => t);
                    // Filter out the tag to be deleted (case-insensitive)
                    modelTags = modelTags.filter(t => t.toLowerCase() !== tagToDelete.toLowerCase());
                    const newTagsString = modelTags.join(', ');
                    
                    return supabase.from('models').update({ tags: newTagsString }).eq('id', model.id);
                });
                await Promise.all(updates);
            }
        }
        
        // 3. Success
        await refreshTagData(); // <-- REPLACED loadTags()
        await loadTagsForManagement(); // Refresh the list in the modal
        loadCards(true); // Refresh main gallery in case tags changed
        
      } catch (error) {
        console.error("Error deleting tags:", error);
        errorMsg.textContent = `Failed to delete tags: ${error.message}.`;
        errorMsg.style.display = 'block';
      }
    }
    // END: Replaced deleteTag

    // START: New function to rename a tag
    async function handleRenameSelectedTag() {
      const selectedTags = getSelectedManageTags();
      const errorMsg = document.getElementById('manageTagsErrorMessage');
      
      if (selectedTags.length !== 1) {
        errorMsg.textContent = 'Please select exactly one tag to rename.';
        errorMsg.style.display = 'block';
        return;
      }

      const oldTagName = selectedTags[0];
      const newTagName = prompt(`Enter new name for "${oldTagName}":`, oldTagName);

      if (!newTagName || newTagName.trim() === '' || newTagName.trim() === oldTagName) {
        errorMsg.textContent = 'Rename cancelled or name unchanged.';
        errorMsg.style.display = 'block';
        return;
      }
      
      const trimmedNewName = newTagName.trim();
      
      // Check if new tag name already exists
      // UPDATED: Logic fixed to ignore the tag being renamed
      const otherTagsLower = allTags.map(t => t.toLowerCase()).filter(t => t !== oldTagName.toLowerCase());
      if (otherTagsLower.includes(trimmedNewName.toLowerCase())) {
          errorMsg.textContent = `Tag "${trimmedNewName}" already exists.`;
          errorMsg.style.display = 'block';
          return;
      }

      try {
        errorMsg.style.display = 'none';

        // 1. Update 'tags' table
        const { error: updateTagError } = await supabase
          .from('tags')
          .update({ name: trimmedNewName })
          .eq('name', oldTagName);
          
        if (updateTagError) throw updateTagError;
        
        // 2. Update tag in all models
        // UPDATED: Changed .eq. to .ilike. for case-insensitivity
        const orQuery = `tags.ilike."${oldTagName}",tags.ilike."${oldTagName},%",tags.ilike."%,${oldTagName}",tags.ilike."%,${oldTagName},%"`;
        const { data: models, error: fetchModelsError } = await supabase
            .from('models')
            .select() // <-- ADDED .select()
            .or(orQuery);
        
        if (fetchModelsError) throw new Error(`Error fetching models for tag ${oldTagName}: ${fetchModelsError.message}`);

        if (models && models.length > 0) {
            const updates = models.map(model => {
                let modelTags = (model.tags || '').split(',').map(t => t.trim()).filter(t => t);
                // Find and replace the tag (case-insensitive)
                modelTags = modelTags.map(t => t.toLowerCase() === oldTagName.toLowerCase() ? trimmedNewName : t);
                // Remove duplicates just in case
                const newTagsString = [...new Set(modelTags)].join(', '); 
                
                return supabase.from('models').update({ tags: newTagsString }).eq('id', model.id);
            });
            await Promise.all(updates);
        }
        
        // 3. Success
        await refreshTagData(); // <-- REPLACED loadTags()
        await loadTagsForManagement(); // Refresh the list in the modal
        loadCards(true); // Refresh main gallery in case tags changed
        
      } catch (error) {
        console.error("Error renaming tag:", error);
        errorMsg.textContent = `Failed to rename tag: ${error.message}.`;
        errorMsg.style.display = 'block';
      }
    }
    // END: New function to rename a tag
    
    // --- END: Tag Management Modal Functions ---
    
    // --- START: Quick Edit Modal Functions ---
    
    async function openQuickEditModal(cardId) {
      try {
        const { data: card, error } = await supabase.from('models').select('*').eq('id', cardId).single();
        if (error) throw error;

        document.getElementById('quickEditCardId').value = card.id;
        document.getElementById('quickEditModelUrl').value = card.main_model_url;
        document.getElementById('quickEditModelNsfw').checked = card.nsfw; // <-- ADDED
        
        quickEditSelectedTags = card.tags ? card.tags.split(',').map(tag => tag.trim()).filter(tag => tag) : [];
        
        updateQuickEditSelectedTagsDisplay();
        updateQuickEditAvailableTags();
        
        document.getElementById('quickEditErrorMessage').style.display = 'none';
        document.getElementById('quick-edit-modal').style.display = 'flex';
      } catch (error) {
        console.error("Error loading card for quick edit:", error);
        alert("Failed to load card for editing");
      }
    }
    
    function closeQuickEditModal() {
      document.getElementById('quick-edit-modal').style.display = 'none';
      document.getElementById('quickEditForm').reset();
      quickEditSelectedTags = [];
      document.getElementById('quickEditErrorMessage').style.display = 'none';
    }
    
    async function handleQuickUpdate() {
      const cardId = document.getElementById('quickEditCardId').value;
      const newUrl = document.getElementById('quickEditModelUrl').value.trim();
      const newTags = quickEditSelectedTags.join(', ');
      const newNsfw = document.getElementById('quickEditModelNsfw').checked; // <-- ADDED
      const errorMsg = document.getElementById('quickEditErrorMessage');

      if (!newUrl) {
        errorMsg.textContent = "Image URL is required.";
        errorMsg.style.display = 'block';
        return;
      }
      
      try {
        // Update the database and get the updated row back
        const { data: updatedCard, error } = await supabase
          .from('models')
          .update({ 
            main_model_url: newUrl,
            tags: newTags,
            nsfw: newNsfw // <-- ADDED
          })
          .eq('id', cardId)
          .select()
          .single(); // .select().single() returns the updated row
        
        if (error) throw error;
        
        // START: Update card in local array
        const index = displayedCards.findIndex(c => c.id == cardId);
        if (index !== -1) {
          // Preserve album flags, update the rest
          const oldCard = displayedCards[index];
          displayedCards[index] = {
            ...updatedCard,
            isAlbum: oldCard.isAlbum,
            albumTag: oldCard.albumTag,
            isAlbumCover: oldCard.isAlbumCover,
            albumName: oldCard.albumName // <-- ADDED
          };
        }
        // END: Update local card
        
        // REPLACED local update with a full refresh for consistency
        closeQuickEditModal();
        await refreshTagData();
        loadCards(true); // This will refresh the gallery with all changes
        
      } catch (error) {
        console.error("Error updating card:", error);
        errorMsg.textContent = `Failed to update: ${error.message}`;
        errorMsg.style.display = 'block';
      }
    }
    
    // --- Tag Helpers for Quick Edit Modal ---
    
    function updateQuickEditAvailableTags() {
      const availableTagsSelect = document.getElementById('quickEditAvailableTags');
      availableTagsSelect.innerHTML = '<option value="">Select tags to add</option>';
      allTags.forEach(tag => {
        if (tag.startsWith('album:')) { return; } // Don't show
        if (!quickEditSelectedTags.includes(tag)) {
          const option = document.createElement('option');
          option.value = tag;
          option.textContent = tag;
          availableTagsSelect.appendChild(option);
        }
      });
    }

    function addTagToQuickEdit() {
      const select = document.getElementById('quickEditAvailableTags');
      const selectedTag = select.value;
      if (!selectedTag || quickEditSelectedTags.includes(selectedTag)) { return; }
      
      quickEditSelectedTags.push(selectedTag);
      updateQuickEditSelectedTagsDisplay();
      updateQuickEditAvailableTags();
      select.value = "";
    }
    
    function updateQuickEditSelectedTagsDisplay() {
      const container = document.getElementById('quickEditSelectedTagsContainer');
      container.innerHTML = '';
      quickEditSelectedTags.forEach(tag => {
        // START: Don't allow removing album tags
        const isAlbumTag = tag.startsWith('album:');
        
        const tagElem = document.createElement('span');
        tagElem.className = `px-3 py-1 ${isAlbumTag ? 'bg-gray-700 text-gray-400' : 'bg-blue-600 text-white'} text-sm rounded-full flex items-center gap-2`;
        
        let removeButton = '';
        if (!isAlbumTag) {
          removeButton = `<button type="button" class="text-blue-200 hover:text-white" onclick="removeQuickEditSelectedTag('${tag}')">&times;</button>`;
        }
        
        const displayName = isAlbumTag ? `Album: ${tag.substring(6).replace(/-/g, ' ')}` : tag;
        
        tagElem.innerHTML = `${displayName} ${removeButton}`;
        container.appendChild(tagElem);
        // END
      });
    }

    function removeQuickEditSelectedTag(tagToRemove) {
      quickEditSelectedTags = quickEditSelectedTags.filter(tag => tag !== tagToRemove);
      updateQuickEditSelectedTagsDisplay();
      updateQuickEditAvailableTags();
    }
    
    // --- END: Quick Edit Modal Functions ---
    
    // --- START: New function to add to album ---
    function openUploadForAlbum() {
      const card = displayedCards[currentViewerIndex];
      if (!card || !card.isAlbum || !card.albumName) {
        console.error("Cannot add to album, card data missing.", card);
        return;
      }
      
      // 1. Close the viewer
      closeImageViewer();
      
      // 2. Open popup (this resets the form via closePopup -> resetForm)
      openPopup();
      
      // 3. Pre-fill album name
      document.getElementById('modelAlbumName').value = card.albumName;
      
      // 4. Pre-fill tags
      const allCardTags = card.tags ? card.tags.split(',').map(t => t.trim()).filter(t => t) : [];
      
      // Get all tags *except* the album: tag and the album display name tag
      selectedTags = allCardTags.filter(t => 
        !t.startsWith('album:') && 
        t.toLowerCase() !== card.albumName.toLowerCase()
      );
      
      // Re-update selected tags display (which will now be pre-filled)
      updateSelectedTagsDisplay();
      // Re-update available tags dropdown
      updateTagDisplays();
    }
    // --- END: New function to add to album ---
    
    // --- START: Shuffle Utility Function ---
    /**
     * Shuffles an array in place using the Fisher-YATES algorithm.
     * @param {Array} array The array to shuffle.
     */
    function shuffleArray(array) {
      let currentIndex = array.length,  randomIndex;
      // While there remain elements to shuffle.
      while (currentIndex != 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
          array[randomIndex], array[currentIndex]];
      }
      return array;
    }
    // --- END: Shuffle Utility Function ---

    // START: New Tag Refresh Function
    async function refreshTagData() {
      await loadTagCounts();
      await loadTags(); // loadTags will now use the new tagCountMap
    }
    // END: New Tag Refresh Function

  </script>
</body>
</html>
